function [ taskData, stimTiming ] = preprocessLogFileMonkeyLogic(logfile, taskTriggers, diodeTriggers, params)
%Sync log file's timestamps to blackrock clock, and store: 
%  - in presentation order, stimulus filenames, start/end times and jump RF mapping positions
%  - task event times: fixation in/out, fixspot flash start/end, juice delivery start/end 
%  - currently, uses digital IO packets for synchronization. In future
%    implementation, will optionally refine this sync with photodiode traces
%   Inputs:
%   - logFilename: an xml file generated by Visiko (or, in other
%     implementations, some other stimulation software)
%   - taskTriggers: digital IO data from blackrock NEV file
%   - params: currently must be struct of form params.usePhotodiode = 0
%   Outputs:
%   - taskData: struct with fields:
%       - taskEventIDs: nTrials x 1 cell array of alignment point identifiers, e.g. stimulus filenames. 
%         Used to retrieve information from stimulusParamFile.
%       - taskEventStartTimes: nTrials x 1 array of task event (e.g. stimulus) start times in ms
%       - taskEventEndTimes: nTrials x 1 array of task event (e.g. stimulus) end times in ms
%       _ stimParams: struct containing information about stimulus size etc. Not currently used elsewhere, so may be left empty
%       - RFmap: 1 for runs where stimulus position varies, else 0
%       - stimJumps: if RFmap, nTrialsx2 array or stim x and y positions, in degrees of visual angle, else may be empty
%           - note: position relative to center of jump grid, not absolute position
%       - gridPointsDegX: if RFmap, 1xN array of unique stimulus jump X locations, else may be empty 
%       - gridPointsDegY: if RFmap, 1xN array of unique stimulus jump Y locations, else may be empty
%       - fields likely required for excludeStimuli and runSummary plots (may be left empty if not needed):
%         - stimFramesLost: nTrials x 1, number of frames lost during trial
%         - fixationInTimes: nTrials x 1, times in ms when fixation epochs begin
%         - fixationOutTimes: nTrials x 1, times in ms when fixation epochs end
%         - juiceOnTimes: nTrials x 1, times in ms when juice delivery begins
%         - juiceOffTimes: nTrials x 1,times in ms when juice delivery ends
%         - fixSpotFlashStartTimes: nTrials x 1, times in ms when flash begins
%         - fixSpotFlashEndTimes: nTrials x 1, times in ms when flash ends
%   Dependencies:
%   - Statistics and Machine Learning Toolbox (for synchronizaton)
%   - xml2struct (from Matlab fileExchange)

% if params.usePhotodiode
%   error('photodiode synchronization not enabled');
% end

disp('parsing serial IO packets');
packetTimes = double(taskTriggers.TimeStampSec)*1000; %convert seconds to milliseconds
packetData = double(taskTriggers.UnparsedData);

assert(logical(~isempty(packetData)),'The Blackrock Digital inputs are empty. Digital inputs may have not been plugged in.');

% OVERALL PLAN - Don't reference the eventmarkers as signs of stim on time,
% use the closest strobe swap to the arrival of that marker instead.

% Find the time stamps for the stimuli presentation. 
% taskEventStartTimesBlk = packetTimes(packetData == 20);  %Blk affix signifies Blackrock reference frame
% taskEventEndTimesBlk = packetTimes(packetData == 30);
% fprintf('number of stim triggers received by blackrock: %s \n', num2str(length(taskEventStartTimesBlk)));
%clear packetData; %Seemingly still of use later.

%Parse the Log file
disp('Loading MonkeyLogic log file');
assert(logical(exist(logfile,'file')),'The logfile you requested does not exist.');
logStruct = load(logfile); %This will be a .mat with cells connecting stimulus to array.

%Find stimulus timing range - in ML, we have no range within valid trials.
stimTiming.shortest = 2800; %Making this 0 for now
stimTiming.longest = 2800; %setting this to 2800 for now, but maybe save as an editable variable.
stimTiming.ISI = logStruct.MLConfig.InterTrialInterval;

%Construct the translation table from the logfile
%Find the Conditions that need to be connected to codes
allConditions = unique(logStruct.TrialRecord.ConditionsPlayed); %Pull unique members of this list
translationTable = cell(length(allConditions),1); %Initialize translation table
trial_ind = 1;

%Check for empty members of the translation table. 
while sum(find(cellfun('isempty', translationTable))) ~= 0
    trialHolder = eval(sprintf('logStruct.Trial%s', num2str(trial_ind)));
    stimName = trialHolder.TaskObject.Attribute(2).Name; %Pull the string containing the stimulus name.
    translationTable{trialHolder.Condition} = stimName(~isspace(stimName));
    trial_ind = trial_ind + 1;
end

%Pull Behavioral codes for other events
behavioralCodes = logStruct.TrialRecord.TaskInfo.BehavioralCodes;

trialStartMarker = behavioralCodes.CodeNumbers(find(strcmp(behavioralCodes.CodeNames,'Start trial')));
stimStartMarker = behavioralCodes.CodeNumbers(find(strcmp(behavioralCodes.CodeNames,'Stimuli On')));
stimEndMarker = behavioralCodes.CodeNumbers(find(strcmp(behavioralCodes.CodeNames,'Stimuli Off')));
rewardMarker = behavioralCodes.CodeNumbers(find(strcmp(behavioralCodes.CodeNames,'Reward')));
frameSkipMarker = behavioralCodes.CodeNumbers(find(strcmp(behavioralCodes.CodeNames,'Frame skipped')));
trialEndMarker = behavioralCodes.CodeNumbers(find(strcmp(behavioralCodes.CodeNames,'End trial')));
manualRewardMarker = behavioralCodes.CodeNumbers(find(strcmp(behavioralCodes.CodeNames,'Manual reward')));

%Code to get rid of any markers prior to the first trial beginning (means
%we turned on blackrock AFTER beginning MKL.
lol = find(packetData == trialStartMarker);
packetData = packetData(lol(1):end);
packetTimes = packetTimes(lol(1):end);

%Comb through the Blackrock data and pull codes/times associated w/ valid
%trials. 
[taskEventStartTimesBlk, taskEventEndTimesBlk, juiceOnTimesBlk, juiceOffTimesBlk, taskEventIDs_condnum] = deal(zeros(sum(packetData == 40), 1));
trueTrialcount = 1;

for ii = 1:length(packetData)
    if packetData(ii) > 100
        stimCondTemp = packetData(ii);
    elseif packetData(ii) == stimStartMarker
        stimStartTemp = packetTimes(ii);
    elseif packetData(ii) == stimEndMarker
        stimEndTemp = packetTimes(ii);
    elseif packetData(ii) == 40 %This assumes the "juice end time" is right after this marker.
        taskEventIDs_condnum(trueTrialcount) = stimCondTemp;
        taskEventStartTimesBlk(trueTrialcount) = stimStartTemp;
        taskEventEndTimesBlk(trueTrialcount) = stimEndTemp;
        juiceOnTimesBlk(trueTrialcount) = packetTimes(ii);
        juiceOffTimesBlk(trueTrialcount) = packetTimes(ii + 1);
        trueTrialcount = trueTrialcount + 1;
    end
end

%We now have the start of trials, as per the eventmarkers. We want to move
%that to strobe space. This will be done by finding the transitions for the
%strobe from High (white) to low (black) closest to the time stamp.

%What is the discrepency?
offsets = zeros(sum(packetData == 40),1);


if length(diodeTriggers.low) < length(diodeTriggers.mid) 
    for ii = 1:length(taskEventStartTimesBlk)
        [offsets(ii), ind_truestart] = min(abs(diodeTriggers.highToMid-taskEventStartTimesBlk(ii)));
        taskEventStartTimesBlk(ii) = diodeTriggers.highToMid(ind_truestart);
    end
    %do the same for the end times, except referencing the nearest Low to high
    %transition.
    for ii = 1:length(taskEventEndTimesBlk)
        [offsets(ii), ind_truestart] = min(abs(diodeTriggers.midToHigh-taskEventEndTimesBlk(ii)));
        taskEventEndTimesBlk(ii) = diodeTriggers.midToHigh(ind_truestart);
    end    
else
    for ii = 1:length(taskEventStartTimesBlk)
        [offsets(ii), ind_truestart] = min(abs(diodeTriggers.highToLow-taskEventStartTimesBlk(ii)));
        taskEventStartTimesBlk(ii) = diodeTriggers.highToLow(ind_truestart);
    end
    %do the same for the end times, except referencing the nearest Low to high
    %transition.
    for ii = 1:length(taskEventEndTimesBlk)
        [offsets(ii), ind_truestart] = min(abs(diodeTriggers.lowToHigh-taskEventEndTimesBlk(ii)));
        taskEventEndTimesBlk(ii) = diodeTriggers.lowToHigh(ind_truestart);
    end
end

fprintf('average offset %s ms\n', num2str(mean(offsets)))
fprintf('range of offset %d ms - %d ms \n', [min(offsets), max(offsets)])

%for every trial, find the conditions number and convert it to the
%appropriate filename for the stimulus, based on the translation table created earlier.
taskEventIDs_condnum = taskEventIDs_condnum - 100; %This is a number I set in my timing script.
taskEventIDs = cell(1, length(taskEventIDs_condnum));
for ii = 1:length(taskEventIDs_condnum)
    taskEventIDs(ii) = translationTable(taskEventIDs_condnum(ii)); %Reference the translation table w/ the condition ID as an index
end

Output.VERBOSE(sprintf('number of stimulus trials: %s',length(taskEventIDs))); %num2str needed?
%stimJumps = stimJumps(taskEventStartTimesLog >= 0,:); %note: jumps can be negative, so use startTime for logical indexing
% I don't think these things can be Negative in ML.
% stimFramesLost = stimFramesLost(stimFramesLost >= 0);
% taskEventStartTimesLog = taskEventStartTimesLog(taskEventStartTimesLog >= 0);
% taskEventEndTimesLog = taskEventEndTimesLog(taskEventEndTimesLog >= 0);

%Adding these as 0s.
fixSpotFlashStartTimesBlk = taskEventStartTimesBlk(1);
fixSpotFlashEndTimesBlk = taskEventEndTimesBlk(1);
fixationInTimesBlk = taskEventStartTimesBlk(2);
fixationOutTimesBlk = taskEventEndTimesBlk(end);

% finally, build the output structure
taskData.taskEventIDs = taskEventIDs';
%taskData.stimJumps = stimJumps;
%taskData.stimFramesLost = stimFramesLost;
taskData.taskEventStartTimes = taskEventStartTimesBlk;
taskData.taskEventEndTimes = taskEventEndTimesBlk;
taskData.fixationInTimes = fixationInTimesBlk;
taskData.fixationOutTimes = fixationOutTimesBlk;
taskData.juiceOnTimes = juiceOnTimesBlk;
taskData.juiceOffTimes = juiceOffTimesBlk;
taskData.fixSpotFlashStartTimes = fixSpotFlashStartTimesBlk;
taskData.fixSpotFlashEndTimes = fixSpotFlashEndTimesBlk;
taskData.stimParams = 0;
taskData.RFmap = 0;
taskData.eyeCal.origin = logStruct.MLConfig.EyeTransform{2}.origin;
taskData.eyeCal.gain = logStruct.MLConfig.EyeTransform{2}.gain;

end
%
