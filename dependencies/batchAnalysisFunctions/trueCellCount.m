function [trueCellInd, analyzedTaskDates, unitCountStruct] = trueCellCount(batchRunxls, recordingLogxls)
%% Function
% uses information from batchRunxls and recordingLogxls to determine which 
% units within recordings are new (as opposed to phase 2, or slight changes in depth.)

% Input
% batchRunxls - the path to an xls generated by the processRunBatch, with columns of
% 'File_Analyzed' (in the typical sessionNameRun format), 
% recordingLogxls - the path to a personally annotated log of recording information.
% has to have properly formatted information on grid hole, depth, and
% session name in the correct format. 
performSigCounts = 1;
%% Analysis
% Read both excel tables.
logTable = readtable(recordingLogxls);                % Grab the record with task information from Recordings excel.
analysisTable = readtable(batchRunxls, 'Sheet', 1);   % Grab the first sheet of the analysis table (1 sheet per Epoch).

% Code Below for finding unique grid holes and their counts.
gridHolesTotal = [logTable.ML logTable.AP];
gridHolesG1 = [logTable.ML(1:44) logTable.AP(1:44)];      %44 is the end of June/July
gridHolesG2 = [logTable.ML(45:end) logTable.AP(45:end)];  %45 is beginning of August
uniqueGridHolesG1 = unique(gridHolesG1,'rows');
uniqueGridHolesG2 = unique(gridHolesG2,'rows');

% Process the task information to find a vector of cells with run title and
% whether this run was a follow up or not.
% Specifically, if a run has the same date, depth, and channel as a previous
% recording, do not include it.
uniqueChannels = unique(logTable.Channel);
recordingDepth = cellfun(@str2double, logTable.putativeDistance);
taskDateRunNum = logTable.recording;
taskDate = extractBetween(taskDateRunNum,1,8);
taskDateNum = str2num(cell2mat(taskDate));
% the date changed (different date = 1)
dateChangeInd = [1; logical(diff(taskDateNum))]; %Still works for 2 channels.

%For every recording...
chanDepthChangeInd = zeros(size(dateChangeInd));
for ch_ind = 1:length(uniqueChannels)
  % find the recordings to compare
  matchInd = (logTable.Channel == uniqueChannels(ch_ind));
  % the depth changed < 100 microns from the last record (>100 = 1)
  chanRecordingDepth = recordingDepth(matchInd);
  depthChange = diff(chanRecordingDepth);
  sigDepthChangeInd = [1; abs(depthChange) > 100];
  chanDepthChangeInd(matchInd) = sigDepthChangeInd;
end

%If the run took place on a new day or over 100 microns deeper, count it.
validUnitInd = logical(dateChangeInd+chanDepthChangeInd);

%Use this validUnitInd to generate an index of valid runs for the analysis
%performed, details of which are in the analysisTable.
analyzedTaskDates = analysisTable.File_Analyzed;
unitCounts = analysisTable.Unit_Count;
[~, B] = ismember(analyzedTaskDates,taskDateRunNum); % Find matching entries

% Use the indicies of the matches to generate an index for units to count
% in a particular analysis
trueCellInd = validUnitInd(B);
AnalyzedTaskRuns = taskDateRunNum(B);
gridHoles = gridHolesTotal(B,:);
unitCount = sum(unitCounts(trueCellInd));
unitCountStruct.total =  unitCount;
validTaskRuns = AnalyzedTaskRuns(trueCellInd);
validGridHoles = gridHoles(trueCellInd,:);

%% Signifiance Counts (Null Model and ANOVA)
if performSigCounts
  % the processRunBatch currently compiles results of Null model testing and ANOVAs performed within
  % each run. ANOVAs are represented as a string of brackets, 1 per unit, including Unsorted and MUA (per phyzzy convention).
  sheetNames = {'Presentation','Fixation','Reward'};
  unitCountStruct.epochs = sheetNames;
  resultTable = struct();
  lengthPerBlock = 0;
  [unitCountStruct.sigUnitCountNull , unitCountStruct.sigUnitCountANOVA] = deal(zeros(length(sheetNames),1));
  
  for table_ind = 1:3
    % Load the sheet corresponding to the correct epoch.
    analysisTable = readtable(batchRunxls, 'Sheet', table_ind);
    
    % Null Model counts
    sigUnitCounts = analysisTable.SigUnitCount;
    validSigUnitCounts = sigUnitCounts(trueCellInd);
    sigTaskRuns = validTaskRuns(logical(validSigUnitCounts));
    sigGridHoles = validGridHoles(logical(validSigUnitCounts),:);
    
    sigUnitCount = sum(sigUnitCounts(trueCellInd));     % significant unit count
    fractionSig = sigUnitCount/unitCount;               % Percent Significant
    
    % ANOVA counts
    
    % Parse ANOVA strings.
    ANOVAStrings = analysisTable.ANOVA;
    ANOVAStrings = strrep(ANOVAStrings,' ','');
    extractB = @(x) extractBetween(x, 2, length(x)-1);
    ANOVAStrings = cellfun(extractB, ANOVAStrings);
    breakCells = @(x) strsplit(x, '][');
    ANOVACells = cellfun(breakCells, ANOVAStrings,'UniformOutput',0);
    
    % Use trueCellInd to exclude repeated units.
    ANOVACells = ANOVACells(trueCellInd);
    
    % Initialize vectors for counts
    [TaskModUnsortedCount, TaskModMUACount, TaskModUnitCount] = deal(0);
    [SocSigUnsortedCount, SocSigMUACount, SocSigUnitCount] = deal(0);
    [sigUnitRunIndA, sigUnitRunIndTM, sigUnitGridHole] = deal([]);
    
    % Iteratate accross runs and count.
    for run_ind = 1:length(ANOVACells)
      for cell_ind = 1:length(ANOVACells{run_ind})
        ANOVAResult = ANOVACells{run_ind}{cell_ind};
        
        % first index identifies task modulation.
        if str2double(ANOVAResult(1))
          if cell_ind == 1
            TaskModUnsortedCount = TaskModUnsortedCount + 1;
          elseif cell_ind == length(ANOVACells{run_ind})
            TaskModMUACount = TaskModMUACount + 1;
          else
            TaskModUnitCount = TaskModUnitCount + 1;
            sigUnitRunIndTM = [sigUnitRunIndTM; run_ind];
          end
        end
        
        % 2nd number (index 3) identifies social selectivity on ANOVA.
        if str2double(ANOVAResult(3))
          if cell_ind == 1
            SocSigUnsortedCount = SocSigUnsortedCount + 1;
          elseif cell_ind == length(ANOVACells{run_ind})
            SocSigMUACount = SocSigMUACount + 1;
          else
            SocSigUnitCount = SocSigUnitCount + 1;
            sigUnitRunIndA = [sigUnitRunIndA; run_ind];
            sigUnitGridHole = [sigUnitGridHole; validGridHoles(run_ind,:)];
          end
        end
      end
    end
    
    % Save the total counts into a cell for the table.
    resultTable(table_ind).taskMod = unique(validTaskRuns(sigUnitRunIndTM));
    resultTable(table_ind).SigANOVA = validTaskRuns(sigUnitRunIndA);
    resultTable(table_ind).SigNull = sigTaskRuns;
    resultTable(table_ind).sigANOVAGrid = sigUnitGridHole;
    resultTable(table_ind).sigNullGrid = sigGridHoles;
    
    % Report
    if table_ind == 1
      fprintf('Total Non-repeat units: %d \n',unitCount)
    end
    fprintf('Total Null Model %s Sig units: %d \n',sheetNames{table_ind}, sigUnitCount)
    unitCountStruct.sigUnitCountNull(table_ind) = sigUnitCount;
    fprintf('\n');
    fprintf('Total task modulated units: %d \n',TaskModUnitCount)
    fprintf('Total %s units found via ANOVA : %d \n', sheetNames{table_ind},SocSigUnitCount)
    unitCountStruct.sigUnitCountANOVA(table_ind) = SocSigUnitCount;
    
    % output will be an excel table. This number below will be used for proper formating.
    lengthPerBlock = max([lengthPerBlock; length(sigUnitRunIndA); length(sigTaskRuns)]);
  end
  
  % Unique Grid Hole counting
  [sigHolesA, ~, sigHoleAC] = unique(resultTable(1).sigNullGrid(5:end,:),'row'); %5 starts August, first 4 dates are dates in J/J.
  [sigHolesJJ, ~, sigHoleJJC] = unique(resultTable(1).sigNullGrid(1:4,:),'row'); %5 starts August, first 4 dates are dates in J/J.
  A_counts = accumarray(sigHoleAC,1);
  JJ_counts = accumarray(sigHoleJJC,1);
  sigHolesA_Counts = [A_counts, sigHolesA];
  sigHolesJJ_Counts = [JJ_counts, sigHolesJJ];
  
  
  [sigHolesA, ~, sigHoleAC] = unique(resultTable(1).sigANOVAGrid(6:end,:),'row'); %5 starts August, first 4 dates are dates in J/J.
  [sigHolesJJ, ~, sigHoleJJC] = unique(resultTable(1).sigANOVAGrid(1:5,:),'row'); %5 starts August, first 4 dates are dates in J/J.
  A_counts = accumarray(sigHoleAC,1);
  JJ_counts = accumarray(sigHoleJJC,1);
  sigHolesA_Counts = [A_counts, sigHolesA];
  sigHolesJJ_Counts = [JJ_counts, sigHolesJJ];
  
  tableCell = cell((lengthPerBlock + 1) * 2,3);
  fileParts = split(fileparts(batchRunxls),filesep);
  resultName = fileParts{end};
  [tableCell(1,1:3), tableCell(2 + lengthPerBlock ,1:3)] = deal(sheetNames);
  
  for result_ind = 1:length(resultTable)
    columnLength = length(resultTable(result_ind).SigNull);
    columnLength2 = length(resultTable(result_ind).SigANOVA);
    tableCell(2:columnLength+1,result_ind) = resultTable(result_ind).SigNull;
    tableCell(lengthPerBlock+3:lengthPerBlock+2+columnLength2,result_ind) = resultTable(result_ind).SigANOVA;
  end
  
  T = cell2table(tableCell);
  writetable(T,fullfile(fileparts(batchRunxls),sprintf('%s_sigRuns.xlsx',resultName)))
end
%% Comparing Lists
% taskMod = resultTable(1).taskMod;
% taskModIntersect = setdiff(resultTable(1).SigNull, taskMod);
% DoubleSigPres = intersect(resultTable(1).SigANOVA, resultTable(1).SigNull);
% DoubleSigFix = intersect(resultTable(2).SigANOVA, resultTable(2).SigNull);
% DoubleSigReward = intersect(resultTable(3).SigANOVA, resultTable(3).SigNull);

