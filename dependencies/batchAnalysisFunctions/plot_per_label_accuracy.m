function figh = plot_per_label_accuracy_V2(decoding_results, analysisStruct, params)
% a function which generates a plot containing:
% - single trace per label used in the decoder
% - a mean trace of the overall accuracy
% - vertical lines at important events (denoted below)
% - Relabels X-axis (with numbers below).
% Inputs are
% - decoding_results, ds generated by neural decoding toolbox
% - analysisStruct, generated by k_aid scripts.

% Extract clear variables from inputs.
end_time = decoding_results.DS_PARAMETERS.binned_site_info.binning_parameters.end_time;
binArray = [decoding_results.DS_PARAMETERS.time_periods_to_get_data_from{:}];

points_to_label = params.plotParams.points_to_label;
points_for_lines = params.plotParams.points_for_lines;

p_val_threshold = params.p_val_threshold;
sig_bins = params.sig_bins;
shift = decoding_results.DS_PARAMETERS.binned_site_info.binning_parameters.alignment_event_time;

figStruct = params.figStruct;
plotP = params.plot_per_label_acc;
justMean = plotP.justMean;
plotMean = plotP.plotMean;
chanceAtBottom = plotP.chanceAtBottom;
plotError = plotP.plotError;
plotEachLabel = plotP.plotEachLabel;
groupNames = plotP.groupNames;
groups = plotP.groups;
sig_bar_pos = plotP.sig_bar_pos;
sig_color = plotP.sig_color;

% Identify what the x axis will represent.
binLabel = plotP.binLabel;
switch binLabel
  case 'End'
    offSet = params.binWidth;
  case 'Middle'
    offSet = params.binWidth/2;
end
the_bin_times = (1:params.stepSize:(end_time - params.binWidth  + 1)) + offSet;

% Find Labels
labels = decoding_results.DS_PARAMETERS.label_names_to_use;

if size(labels, 2) > 1
  labels = labels';
end

decoding_type = 'Zero';
switch decoding_type
  case 'Zero'
    decoding_data = decoding_results.ZERO_ONE_LOSS_RESULTS;
  case 'Normalized'
    decoding_data = decoding_results.NORMALIZED_RANK_RESULTS;
  case 'ROC_AUC'
    decoding_data = decoding_results.ROC_AUC_RESULTS;
end

% Create the plotting results
correctLineMean = decoding_data.mean_decoding_results';
correctLineMeanSTD = decoding_data.stdev.over_CVs_combined_over_resamples';

% Extract a per label correct percentage for each label.
confMat = decoding_data.confusion_matrix_results.confusion_matrix;
confMat = confMat./sum(confMat,1); % Normalize
correctLineStack = nan(size(confMat,1), size(confMat,3));

for bin_i = 1:length(correctLineStack)
  infoTmp = confMat(:, :, bin_i);
  correctLineStack(:, bin_i) = infoTmp(logical(eye(length(infoTmp))));
end

% Create trace w/ mean and std - 
% cvCount = size(decoding_results{1}.ZERO_ONE_LOSS_RESULTS.decoding_results, 1);
% meanTracePerCat = squeeze(mean(decoding_results{1}.ZERO_ONE_LOSS_RESULTS.decoding_results, 1));
% stdTracePerCat = decoding_results{1}.ZERO_ONE_LOSS_RESULTS.stdev.over_CVs_combined_over_resamples;

% Check if plotting error was requested, despite not having many lines.
if size(correctLineStack, 1) == 1 && plotError
  warning('There is only 1 decoding result, no error line to plot')
  plotError = 0;
end

if length(labels) == 2
  warning('Binary Decoder forced to plotting of just Mean')
  justMean = 1;
end

figTitle = sprintf('Decoding for %s', analysisStruct.plotTitle);
figh = figure('Name', figTitle, 'units', 'normalized', 'outerposition',[.1 .1 0.8 0.8]);

axesh = axes(figh);
axesh.FontSize = 20;
title(figTitle)
hold on
linePlotHandles = gobjects(length(labels) + 2, 1)';

if justMean
  % Initialize this if only plotting.
  plotLabels = {};
else
  % Plot each curve individually.
  linePlotHandles(1:end-2) = plot(correctLineStack', 'linewidth', 3);
  plotLabels = labels;
end

% Plot the mean and chance
sigBarLabel = sprintf('Significant regions (>%s%%)', num2str((1 - p_val_threshold) * 100));
if plotMean || justMean
  linePlotHandles(length(plotLabels) + 1) = plot(correctLineMean, 'linewidth', 5, 'color', 'k');
  linePlotHandles(length(plotLabels) + 1).Tag = 'All Label Mean';
  linePlotHandles(length(plotLabels) + 2) = plot(xlim(), [1/length(labels) 1/length(labels)], 'linewidth', 3, 'color', 'b');
  allLabels = [plotLabels; 'All Label Mean'; 'Theoretical chance'; sigBarLabel];
else
  linePlotHandles(length(plotLabels) + 2) = plot(xlim(), [1/length(labels) 1/length(labels)], 'linewidth', 3, 'color', 'b');
  allLabels = [plotLabels; 'Theoretical chance'; sigBarLabel];
end

if strcmp(sig_bar_pos, 'top')
   % Top 10%
   yLims = [axesh.Position(2)+axesh.Position(4) - axesh.Position(4)/10, axesh.Position(4)/10];
else
   yLims = [axesh.Position(2), axesh.Position(4)/10];
end

decodingAx = gca;

% Add the legend
% legend(linePlotHandles, allLabels, 'AutoUpdate', 'off', 'location', 'northeastoutside')
legH = legend(allLabels, 'AutoUpdate', 'off', 'location', 'northeastoutside');
legH.FontSize = 14

% Label axes correctly
the_bin_times_shift = the_bin_times - shift;
bins_to_label = interp1(the_bin_times_shift, binArray, points_to_label);
x_for_lines = interp1(the_bin_times_shift, binArray, points_for_lines);
xMin = round(interp1(the_bin_times_shift, binArray, points_to_label(1) - 100));

ylabel('Decoding Accuracy')
xlabel(sprintf('Bin %s time', binLabel))
xticks(bins_to_label);
xticklabels(points_to_label);

% Plot Significant p values
[sigBarImgAxs, sigBarHands] = add_bars_to_plots([], [], {sig_bins(xMin:end)}, sig_color, {sig_bins(xMin:end)}, yLims);
linePlotHandles = [linePlotHandles, sigBarHands];

if chanceAtBottom && min(linePlotHandles(1).YData) > 0.2
  ylim([floor(min(correctLineStack(:))*10)/10, 1]);
else
  ylim([0, 1]);
end
xlim([xMin, length(the_bin_times)]);
for ii = 1:length(x_for_lines)
  plot([x_for_lines(ii), x_for_lines(ii)], ylim(), 'linewidth', 4, 'color', [0.2, 0.2, 0.2])
end

% Re-adjust significance bar to align with slightly changed size of plot.
for ii = 1:length(sigBarImgAxs)
  sigBarImgAxs(ii).Position(1:3) = decodingAx.Position(1:3);
  sigBarImgAxs(ii).Position(2) = sigBarImgAxs(ii).Position(2)*1.1;
end

% Save the figure
figData.lineTraces = correctLineMean;
figData.lineSTD = correctLineMeanSTD;
figData.meanTrace = mean(correctLineMean);
figData.sig_bins = sig_bins;
figData.analysisStruct = analysisStruct; % Save the analysisStruct with the figure
figData.the_bin_start_times = the_bin_times;

if justMean
  switchString = 'justMean';
elseif plotMean == 0
  switchString = 'AllTrace';
else
  switchString = 'AllTrace + Mean';
end

saveFigure(analysisStruct.plotOutDir, sprintf('1. %s - %s', figTitle, switchString), figData, figStruct, [])