function [analysisOutFilename] = runBatchAnalysis(inputs)
%%Unpack Inputs
analysisLog = struct();
load(inputs{1})   % Non spike variables, including path to spikes.
spikeDataBank = saveSpikeDataBank([], [], 'load', outputDir); %Spike variables

%Overwrite switches with what is currently in file
load(fullfile(outputDir, 'batchAnalysisParams.mat'));

%% Analyses
runList = fields(spikeDataBank);

if ~isfield(spikeDataBank.(runList{1}), 'stimPresCount')
  spikeDataBank = stimulusStatistics(spikeDataBank);
  %Save modified struct.
  saveSpikeDataBank(spikeDataBank, 5, 'save',outputDir);
end

if plotSwitch.stimPresCount
  disp('plot stimPresCount')
  %Plot as an image the 'daysSinceLastPres' matrix, stimuli on Y, date on
  %X.will likely require a figure callback for making Y axis labels
  %legible.
  %At the top of the plot, I will have a single vector with 'days since
  %last recording' to highlight days after long breaks.
end

if ~exist('unitCounts','var')
  [trueCellInd, trueCellRun, unitCounts] = trueCellCount(cellCountParams.batchRunxls, cellCountParams.recordingLogxls);
end

% Remove repeated Runs
if ~calcSwitch.excludeRepeats && isfield(analysisLog, 'repeatsExcluded')
  error('Repeats already excluded in this spikeDataBank, delete and restart or change parameters')
elseif calcSwitch.excludeRepeats && ~isfield(analysisLog, 'repeatsExcluded')
  % Exclude repeated recordings at the same site.
  for run_ind = 1:length(runList)
    sessionName = extractBetween(runList{run_ind}, 2, length(runList{run_ind}));
    validInd = trueCellInd(strcmp(sessionName,trueCellRun));
    if sum(validInd) == 0
      % Remove entire field if all channels are repeated recordings.
      spikeDataBank = rmfield(spikeDataBank,(runList{run_ind}));
    else
      for event_ind = 1:length(spikeDataBank.(runList{run_ind}).spikesByEvent)
        % Remove individual channel info where one of the channels is
        % recording new units.
        spikeDataBank.(runList{run_ind}).spikesByEvent{event_ind} = spikeDataBank.(runList{run_ind}).spikesByEvent{event_ind}(validInd);
      end
    end
  end
  %Save modified struct.
  analysisLog.repeatsExcluded = 1;
  saveSpikeDataBank(spikeDataBank, 5, 'save',outputDir);
  clearvars spikeDataBank %Delete this to prevent saving with other variables.
  save(fullfile(outputDir, [preprocessParams.spikeDataFileName 'Vars']));
  spikeDataBank = saveSpikeDataBank([], [], 'load', outputDir); % Load spikeDataBank back.
end

%% Combine PSTH across all runs for a particular stimulus.
%This will crash if the PSTHs aren't the same length.
if plotSwitch.meanPSTH % && ~isfield(spikeDataBank, [Some new field generated by function])
  [spikeDataBank, meanPSTHStruct] = meanPSTH(spikeDataBank, meanPSTHParams);
end

%% Gather information on frame rates
if plotSwitch.frameFiringRates
  spikeDataBank = frameFiringRates(spikeDataBank, frameFiringParams);
  saveSpikeDataBank(spikeDataBank, 5, 'save',outputDir);
end

%% Perform sliding window ANOVA and Omega calculations
if plotSwitch.slidingWindowANOVA % && ~isfield(spikeDataBank, [Some new field generated by function])
  spikeDataBank = slidingWindowANOVA(spikeDataBank, slidingANOVAParams);
end

end

function spikeDataBank = stimulusStatistics(spikeDataBank)
% Stimuli Presentation count and 'Novelty' Related Information.
%Code below creates a single large vector of stimuli used, and uses this to
%create individual vectors containing which viewing of the stimulus this
%represent (i.e. 'this run represents the 10th viewing of X.avi'). It also
%appends a dateTime vector to each structure related to how long since the
%last recording day.

runList = fields(spikeDataBank);

%extract the eventIDs field, generate a cell array of unique stimuli
allStimuliVec = struct2cell(structfun(@(x) x.eventIDs, spikeDataBank,'UniformOutput', 0));
allStimuliVec = unique(vertcat(allStimuliVec{:}));

%Produce matrix (N stim * M runs) which gives 0 for non present stim, count of stim presentation otherwise.
stimLogicalArray = zeros(length(allStimuliVec),length(runList));
for run_ind = 1:length(runList)
  stimLogicalArray(:,run_ind) = ismember(allStimuliVec,spikeDataBank.(runList{run_ind}).eventIDs);
end
csStimLogicalArray = cumsum(stimLogicalArray,2);
csStimLogicalArray(~stimLogicalArray) = 0;

% When was a stimulus first seen? Index of runList where first presentation took place.
firstStimPresInd = zeros(length(allStimuliVec),1);
for stim_ind = 1:length(allStimuliVec)
  firstStimPresInd(stim_ind) = find(stimLogicalArray(stim_ind,:),1,'first');
end

% Append a dateTime to each field with the time in days since the last
% recording. Add the relevant slice of the larger csStimLogicalArray.
for run_ind = 1:length(runList)
  spikeDataBank.(runList{run_ind}).stimPresArray = csStimLogicalArray(:,run_ind);
  spikeDataBank.(runList{run_ind}).dateTime = datetime(extractBetween(spikeDataBank.(runList{run_ind}).dateSubject,1,8),'InputFormat','yyyyMMdd');     %Generate 'daysSinceLastRec' for each field.
end

% find unique recording dates, and the distance between them. Add these
% to the spikeDataBank
allDateTimeVec = struct2cell(structfun(@(x) x.dateTime, spikeDataBank,'UniformOutput', 0));
allDateTimeVec = [allDateTimeVec{:}]';
uniqueDateTimeVec = unique(allDateTimeVec);
daysSinceLastRec = [1000; days(diff(uniqueDateTimeVec))];
for run_ind = 1:length(runList)
  spikeDataBank.(runList{run_ind}).daysSinceLastRec = daysSinceLastRec(spikeDataBank.(runList{run_ind}).dateTime == uniqueDateTimeVec);
end

% use the dateTime and stimulus presentation matrix to find out how long
% in days takes place before a particular showing of a stimulus.
daysSinceLastPres = zeros(size(stimLogicalArray));
for stim_ind = 1:size(stimLogicalArray,1)
  presentationInd = logical(stimLogicalArray(stim_ind,:)); %When was the stim shown
  daysSinceLastPres(stim_ind,presentationInd) = [1000; days(diff(allDateTimeVec(presentationInd)))]; %Duration between those dates in days
end

%Return this to spikeDataBank, arranged in way that matches stim table.
for run_ind = 1:size(stimLogicalArray,2)
  [~, big2SmallInd] = ismember(spikeDataBank.(runList{run_ind}).eventIDs,allStimuliVec);
  spikeDataBank.(runList{run_ind}).stimPresCount = daysSinceLastPres(big2SmallInd,run_ind);
end

end

function [spikeDataBank, meanPSTHStruct] = meanPSTH(spikeDataBank, params)
% Function which combines stimulus presentations across all runs in the spikeDataBank. 
% Inputs include spikeDataBank and list of parameters.
meanPSTHStruct = struct();

% Rebuild variables 
%extract the eventIDs field, generate a cell array of unique stimuli
allStimuliVec = struct2cell(structfun(@(x) x.eventIDs, spikeDataBank,'UniformOutput', 0));
allStimuliVec = unique(vertcat(allStimuliVec{:}));

runList = fields(spikeDataBank);

small2BigInd = zeros(length(allStimuliVec), length(runList)); 
for run_ind = 1:length(runList)
  [~, small2BigInd(:,run_ind)] = ismember(allStimuliVec, spikeDataBank.(runList{run_ind}).eventIDs);
end

totalStimPresCount = sum(logical(small2BigInd), 2);

if params.zscorePSTHs
  zTag = 'Z-scored';
else
  zTag = 'raw';
end

if params.broadLabel
  % Broad Label - Swaps labels of individual stimuli for broader catagories,
  % as defined in stimParamFile and the parameters.
  figureTitle = 'Broad Labels';
  tmp = load(params.stimParamsFilename);
  for event_i = 1:length(tmp.paramArray)
    totalEventIDs{event_i} = tmp.paramArray{event_i}{1}; %per the stimParamFile spec, this is the event ID
  end
  totalEventIDs = totalEventIDs';
  [~, paramSortVec] = ismember(allStimuliVec, totalEventIDs);
  paramArray = tmp.paramArray(paramSortVec);
  
  %Iterate across stimuli and assign new labels.
  allStimuliVecTmp = cell(size(allStimuliVec));
  for label_ind = 1:length(allStimuliVec)
    paramStimSet = paramArray{label_ind};
    allStimuliVecTmp{label_ind} = paramStimSet{ismember(paramStimSet,params.broadLabelPool)};
  end
  allStimuliVec = allStimuliVecTmp';
  [uniqueStimLabels, ~, stimIndex] = unique(allStimuliVec);
  
  % Find out how many of each of the newly labeled stimuli there are
  uniqueStimLabelCounts = cell2mat(arrayfun(@(x)length(find(stimIndex == x)), unique(stimIndex), 'Uniform', false));
  
else
  figureTitle = 'per Stimuli';
  [uniqueStimLabels, ~, stimIndex] = unique(allStimuliVec);
end

% Concatonating PSTHs.
groupingType = {'Unsorted','Units','MUA'};
dataType = {'Bins','Max Value','Max Value Ind','Run Ind'};
%stimPSTH{stim}{grouping}{dataType}
stimPSTH = initNestedCellArray([length(uniqueStimLabels), length(groupingType),length(dataType)],'zeros');
          
for stim_ind = 1:length(allStimuliVec)
  % Find the runs where the stimulus was present, generate a list of them.
  stimRunIndex = small2BigInd(stim_ind,:);
  psthStimIndex = nonzeros(stimRunIndex);
  psthRunIndex = find(stimRunIndex);
  subRunList = runList(psthRunIndex);
  
  % Initialize errors for storing relevant information per stimuli
  % cumulativePSTH{groupingType}{dataType}
  cumulativePSTH = initNestedCellArray([length(groupingType),length(dataType)],'zeros');
  
  % For all runs containing a particular stimuli, retrieve relevant activity vector in each.
  for subRun_ind = 1:length(subRunList) %
    tmpRunStruct = spikeDataBank.(subRunList{subRun_ind});
    for chan_ind = 1:length(tmpRunStruct.psthByImage)
      for unit_ind = 1:length(tmpRunStruct.psthByImage{chan_ind})
        % Retrieve correct PSTH from run
        unitActivity = tmpRunStruct.psthByImage{chan_ind}{unit_ind}(psthStimIndex(subRun_ind),:);
        % If desired, Z score PSTHs here based on fixation period activity.
        if params.zscorePSTHs
          fixMean = mean(unitActivity(1:abs(tmpRunStruct.start))); %Find activity during fixation
          fixSD = std(unitActivity(1:abs(tmpRunStruct.start)));
          if fixMean == 0 || fixSD == 0
            % If no spikes take place during the fixation period, use the
            % entire trace to calculate.
            fixMean = mean(unitActivity);
            fixSD = std(unitActivity);
          end
          unitActivity = (unitActivity - fixMean)/fixSD;
        end
        % If only taking peaks during stimulus presentation, store here.
        if params.maxStimOnly
          stimStartInd = abs(tmpRunStruct.start);
          stimEndInd = abs(tmpRunStruct.start) + tmpRunStruct.stimDur;
          [maxVal, maxInd] = max(unitActivity(stimStartInd:stimEndInd));
        else
          [maxVal, maxInd] = max(unitActivity);
        end
        % Concatonate to the correct Matrix (index matching phyzzy convention)
        if unit_ind == 1 % Unsorted
          storeInd = 1;
        elseif unit_ind == length(tmpRunStruct.psthByImage{chan_ind}) % MUA
          storeInd = 3;
        else % Unit
          storeInd = 2;
        end
        cumulativePSTH{storeInd}{1} = [cumulativePSTH{storeInd}{1}; unitActivity];
        cumulativePSTH{storeInd}{2} = [cumulativePSTH{storeInd}{2}; maxVal];
        cumulativePSTH{storeInd}{3} = [cumulativePSTH{storeInd}{3}; maxInd];
        cumulativePSTH{storeInd}{4} = [cumulativePSTH{storeInd}{4}; psthRunIndex(subRun_ind)];
      end
    end
  end
  % Store into Larger cell array to reference
  if isempty(stimPSTH{stimIndex(stim_ind)}{1}{1})
    stimPSTH{stimIndex(stim_ind)} = cumulativePSTH;
  else
    % For overlapping groupings (broad Label), add to sub-structure.
    for group_ind = 1:length(groupingType)
      for data_ind = 1:length(dataType)
        stimPSTH{stimIndex(stim_ind)}{group_ind}{data_ind} = [stimPSTH{stimIndex(stim_ind)}{group_ind}{data_ind}; cumulativePSTH{group_ind}{data_ind}];
      end
    end
  end
end

% Remove stimuli which aren't displayed over params.topStimPresThreshold
% times.
if params.plotTopStim || params.broadLabel
  if params.plotTopStim && ~params.broadLabel
    figureTitle = sprintf('%s with over %d runs', figureTitle, params.topStimPresThreshold);
    topIndex = totalStimPresCount > params.topStimPresThreshold;
  elseif params.broadLabel % For Broad labels, Remove low frequency examples
    figureTitle = sprintf('%s with over 4 stimuli', figureTitle);
    topIndex = uniqueStimLabelCounts > 4;
  end
  stimPSTH = stimPSTH(topIndex);
  uniqueStimLabels = uniqueStimLabels(topIndex);
end

h = gobjects(length(groupingType),length(dataType));
% Cycle through each grouping and data type, plot appropriately
% groupingType = {'Unsorted','Units','MUA'};
% dataType = {'Bins','Max Value','Max Value Ind','Run Ind'};
% stimPSTH{stim}{groupingType}{dataType}

% Region below could be updated to cycle through 'dataType' instead of
% current hardcoded indicies but it doesn't seem worth the effort.

for group_ind = 1:length(groupingType)    
    % Plot Histogram of Peak amplitude across PSTHs.
    histoPeakFigTitle = sprintf('Peak PSTH Bin value - %s', groupingType{group_ind});
    histoIndFigTitle = sprintf('Peak PSTH Times (ms) - %s', groupingType{group_ind});
    
    h(group_ind,1) = figure('NumberTitle', 'off', 'Name', histoPeakFigTitle);
    hold on
    sgtitle(histoPeakFigTitle)
    
    h(group_ind,2) = figure('NumberTitle', 'off', 'Name', histoIndFigTitle);
    hold on
    sgtitle(histoPeakFigTitle)
    
    maxVal = 0;
    minVal = 100;
    [grandTrace, grandSDTrace] = deal([]);
    [meanPSTH, SDPSTH] = deal(zeros(length(stimPSTH), size(stimPSTH{1}{group_ind}{1},2)));

    % Cycle through each stimulus, retrieve the mean and SD of each, plot the
    % histogram of peaks for each.
    for psth_ind = 1:length(stimPSTH)
      % Store traces for grand traces, also calculate states for individual
      % stim.
      grandTrace = [grandTrace; stimPSTH{psth_ind}{group_ind}{1}];
      meanPSTH(psth_ind,:) = mean(stimPSTH{psth_ind}{group_ind}{1});
      grandSDTrace = [grandSDTrace; SDPSTH(psth_ind,:)];
      SDPSTH(psth_ind,:) = std(stimPSTH{psth_ind}{group_ind}{1});
      
      % Histogram of max bins
      set(0, 'CurrentFigure', h(group_ind,1))
      subplot(ceil(length(stimPSTH)/5),5, psth_ind);
      hist(stimPSTH{psth_ind}{group_ind}{2}, 20);
      title(sprintf('%s (mean = %s)',uniqueStimLabels{psth_ind}, num2str(round(mean(stimPSTH{psth_ind}{group_ind}{2}), 2))));
      
      % Histogram of time bins (Inds)
      set(0, 'CurrentFigure', h(group_ind,2))
      subplot(length(stimPSTH),1, psth_ind);
      roundedMaxBinInds = round(stimPSTH{psth_ind}{group_ind}{3}, -1);
      hist(roundedMaxBinInds, 56); %every 50 ms
      title(sprintf('%s (mode = %s)',uniqueStimLabels{psth_ind}, num2str(mode(roundedMaxBinInds))));
            
      %plot(meanPSTH);
      maxVal = ceil(max([maxVal, max(meanPSTH)]));
      minVal = floor(min([minVal, min(meanPSTH)]));
    end

    grandMeanTrace = mean(grandTrace);
    psthTitle = sprintf('Mean %s PSTH Across all %s - %s', zTag, groupingType{group_ind}, figureTitle);
    if params.broadLabel
      newOrder = [1:3,5,7,4,6,8:10]; %Applies to broad labels, puts Control stimuli at bottom.
    else
      newOrder = 1:length(meanPSTH);
    end
    % Plot the Activity PSTH
    h(group_ind,3) = figure('NumberTitle', 'off', 'Name', psthTitle);
    psthAxes = axes();
    psthAxes = plotPSTH(meanPSTH(newOrder,:), psthAxes, params, 'color', psthTitle, uniqueStimLabels(newOrder));
    title(psthTitle)
    grandMeanAxes = axes('YAxisLocation','right','Color', 'none','xtick',[],'xticklabel',[],'xlim',[0 length(grandMeanTrace)]);%,'ytick',[],'yticklabel',[]);
    hold on
    plot(grandMeanAxes, grandMeanTrace,'color','black','lineWidth',4)
    linkprop([psthAxes, grandMeanAxes],{'Position'});
    
    % Plot Standard Deviation PSTH
    grandSDTrace = std(grandTrace);
    psthTitle = sprintf('Mean %s PSTH Std Deviation Across all %s - %s', zTag, groupingType{group_ind}, figureTitle);
    h(group_ind,4) = figure('NumberTitle', 'off', 'Name', psthTitle);
    psthSDAxes = axes();
    psthSDAxes = plotPSTH(SDPSTH(newOrder,:), psthSDAxes, params, 'color', psthTitle, uniqueStimLabels(newOrder));
    title(psthTitle)
    grandSDAxes = axes('YAxisLocation','right','Color', 'none','xtick',[],'xticklabel',[],'xlim',[0 length(grandSDTrace)]);%,'ytick',[],'yticklabel',[]);
    hold on
    plot(grandSDAxes, grandSDTrace,'color','black','lineWidth',4)
    linkprop([psthSDAxes, grandSDAxes],{'Position'});
end
%savefig(h,[batchAnalysisFigDir filesep 'meanPSTHandSD_Figs.fig']);
end

function spikeDataBank = slidingWindowANOVA(spikeDataBank,params)
% Perform sliding scale ANOVA, calculate Omega at each bin.

% Generate variables needed
runList = fields(spikeDataBank);
binSize = params.binSize;
binStep = params.binStep;
target = params.target;
Omega = params.Omega;
stimParamFile = params.stimParamFile;

% Step 1 - generate bin times and spike rates, and proper memberships to groups.
if ~isfield(spikeDataBank.(runList{1}), 'epochRates')
  for run_ind = 1:length(runList)
    runStruct = spikeDataBank.(runList{run_ind});
    starts = (runStruct.start:binStep:(runStruct.end - binSize))';
    ends = (runStruct.start+binSize:binStep:(runStruct.end))';
    spikeDataBank.(runList{run_ind}).epochs = [starts,ends];
    spikeDataBank.(runList{run_ind}).epochRates = cell(length(starts),1);
    for bin_ind = 1:length(starts)
      [spikeDataBank.(runList{run_ind}).epochRates{bin_ind}, ~, ~] = spikeCounter(spikeDataBank.(runList{run_ind}).spikesByEvent, starts(bin_ind), ends(bin_ind));
    end
    for group_ind = 1:length(target)
      groupDef = target{group_ind};
      nestStrCmp = @(x) any(strcmp(x, groupDef));
      spikeDataBank.(runList{run_ind}).catagoryInd(:,group_ind) = cell2mat(cellfun(nestStrCmp, runStruct.eventCategories,'UniformOutput',0));
    end
  end
  saveSpikeDataBank(spikeDataBank, 5, 'save',params.outputDir);
else
  fprintf('Sliding windows rates already calculated, continuing... \n');
end


% Step 2 - Perform ANOVA, Omega calculation, and store values.
% performs an ANOVA on rates across a trial, starting at trial time 0, in some predefined steps.
plotCells = 0;
depth = 2;
for run_ind = 1:length(runList)
  % Check if pValues have already been recorded for this run.
  if ~isfield(spikeDataBank.(runList{length(run_ind)}),'pVec')
    % Initialize relevant Structures
    [pVec, nullVec] = deal(initNestedCellArray(spikeDataBank.(runList{run_ind}).epochRates{1}, 'ones', [length(spikeDataBank.(runList{run_ind}).epochs), length(target)], depth)); % Initialize each p value array.
    omegaVec = initNestedCellArray(spikeDataBank.(runList{run_ind}).epochRates{1}, 'zeros', [length(spikeDataBank.(runList{run_ind}).epochs), length(target)], depth);
    %[maxOmegaVec] = deal(initNestedCellArray(spikeDataBank.(runList{run_ind}).epochRates{1}, 'zeros', [1, length(target)], depth)); % Initialize each p value array.
    if length(unique(spikeDataBank.(runList{run_ind}).catagoryInd)) > 1 %Only run tests where you have members in each group.
      for bin_ind = 1:length(spikeDataBank.(runList{run_ind}).epochs)
        for chan_ind = 1:length(spikeDataBank.(runList{run_ind}).epochRates{bin_ind})
          for unit_ind = 1:length(spikeDataBank.(runList{run_ind}).epochRates{bin_ind}{chan_ind})
            unitResponsePerEvent = spikeDataBank.(runList{run_ind}).epochRates{bin_ind}{chan_ind}{unit_ind};
            catagortyInd = spikeDataBank.(runList{run_ind}).catagoryInd;
            %unitData{event}.rates = trial*1
            for target_ind = 1:length(target)
              if length(unique(catagortyInd(:,target_ind))) == 1
                break % If there is only 1 label type, there is no comparison to be made.
              end
              [trialSpikes, trialLabels]  = deal([]);
              % grab the relevant events
              targetInd = catagortyInd(:,target_ind);
              targetSpikes = unitResponsePerEvent(targetInd);
              otherSpikes = unitResponsePerEvent(~targetInd);
              % Initialize relevant vecotrs
              spikeGroups = {targetSpikes otherSpikes};
              spikeGroupLabels ={(target{target_ind}) (['non-' target{target_ind}])};
              % Cluster and reshape the arrays properly
              for group_i = 1:length(spikeGroups)
                tmp = spikeGroups{group_i};
                tmp = [tmp{:}];
                dataVec = vertcat(tmp.rates);
                labelVec = repmat(spikeGroupLabels(group_i), length(dataVec),1);
                trialSpikes = vertcat(trialSpikes,dataVec);
                trialLabels = vertcat(trialLabels, labelVec);
              end
              % Check for social v non-social
              [pVec{chan_ind}{unit_ind}(bin_ind,target_ind), pStatsTable, ~] = anovan(trialSpikes,{trialLabels},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
              top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
              bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
              omegaVec{chan_ind}{unit_ind}(bin_ind,target_ind) = top/bottom;
              [nullPVec, nullOmegaVec] = deal(zeros(1,100));
              for rand_ind = 1:50
                trialLabels = trialLabels(randperm(length(trialLabels)));
                [nullPVec(rand_ind), pStatsTable, ~] = anovan(trialSpikes,{trialLabels},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
                top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
                bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
                nullOmegaVec(rand_ind) = top/bottom;
              end
              nullVec{chan_ind}{unit_ind}(bin_ind,target_ind) = mean(nullPVec);
              % On the last bin, do the desired stimulus wide calculations
              % for collected traces.
%               if bin_ind == length(spikeDataBank.(runList{run_ind}).epochs)
%                 maxOmegaVec{chan_ind}{unit_ind} = max(omegaVec{chan_ind}{unit_ind});
%               end
            end
          end
        end
      end
    else
      disp('Skipping')
    end
    spikeDataBank.(runList{run_ind}).pVec = pVec;
    spikeDataBank.(runList{run_ind}).nullPVec = nullVec;
%     spikeDataBank.(runList{run_ind}).maxOmegaVec = maxOmegaVec;
    spikeDataBank.(runList{run_ind}).omegaVec = omegaVec;
    % Plot the results for each unit seen
    if plotCells
      for chan_ind = 1:length(pVec)
        for unit_ind = 1:length(pVec{chan_ind})
          if unit_ind == 1
            ANOVAvarName = ['Ch' num2str(chan_ind) ' Unsorted - SocVsNonSoc'];
          elseif unit_ind == length(pVec{chan_ind})
            ANOVAvarName = ['Ch' num2str(chan_ind) ' MUA - SocVsNonSoc'];
          else
            ANOVAvarName = ['Ch' num2str(chan_ind) ' U' num2str(unit_ind-1) ' - SocVsNonSoc'];
          end
          figure()
          plot(pVec{chan_ind}{unit_ind},'linewidth',2)
          hold on
          xlim([0,size(pVec{chan_ind}{unit_ind},1)]);
          ylim([0,1]);
          plot([0,size(pVec{chan_ind}{unit_ind},1)],[0.05, 0.05],'k','linewidth',3)
          title(sprintf('Sliding Scale ANOVA - %s',ANOVAvarName))
          fracSig = round(sum(pVec{chan_ind}{unit_ind} < 0.05)/length(pVec{chan_ind}{unit_ind}), 3, 'significant');
          fragSigNull = round(sum(pVec{chan_ind}{unit_ind} < 0.4)/length(pVec{chan_ind}{unit_ind}), 3, 'significant');
          for leg_ind = 1:length(target)
            legendText{leg_ind} = sprintf('%s (%s;%s)', target{leg_ind}, num2str(fracSig(leg_ind)),num2str(fragSigNull(leg_ind)));
          end
          for null_ind = 1:length(target)
            h.(sprintf('NullLine%d', null_ind)) = mseb(1:length(nullVec{chan_ind}{unit_ind}),nullVec{chan_ind}{unit_ind}(:,null_ind)', errVec{chan_ind}{unit_ind}(:,null_ind)');
            h.(sprintf('NullLine%d', null_ind)).patch.FaceAlpha = '0.5';
          end
          legend(legendText);
        end
      end
    end
    % Every 20 runs, save progress back to the files
    if mod(run_ind,20) == 0 || run_ind == length(runList)
      disp(run_ind)
      saveSpikeDataBank(spikeDataBank, 5, 'save',params.outputDir);
    end
  else
    sprintf('spikeDataBank field already has pVec, moving to next field... \n')
  end
end
sprintf('ANOVA Omega Calculations finished... \n')

% Count Results of ANOVA across all units, count stretches of significant
% bins.
totalUnitCount = 0;
totalChannelCount = 0;
[sigBinCountUnit, sigBinCountUnsorted, sigBinCountMUA, ...
  nulSigBinCountUnit, nulSigBinCountUnsorted, nulSigBinCountMUA] = deal(zeros(length(spikeDataBank.(runList{1}).epochs), length(target)));
sigBinCountTotal = [];
targetRunLengths = struct();
for targ_i = 1:length(target)
  targetRunLengths.(target{targ_i}) = [];
end

for run_ind = 1:length(runList)
  for chan_ind = 1:length(spikeDataBank.(runList{run_ind}).pVec)
    totalChannelCount = totalChannelCount + 1;
    for unit_ind = 1:length(spikeDataBank.(runList{run_ind}).pVec{chan_ind})
      unitLen = length(spikeDataBank.(runList{run_ind}).pVec{chan_ind});
      uPVec = spikeDataBank.(runList{run_ind}).pVec{chan_ind}{unit_ind};
      uNullVec =  spikeDataBank.(runList{run_ind}).nullPVec{chan_ind}{unit_ind};
      % Check for significant bins
      tmpSigCount = uPVec < 0.05;
      tmpNullSigCount = uNullVec < 0.05;
      % Add to relevant structures
      if unit_ind == 1
        sigBinCountUnsorted = tmpSigCount + sigBinCountUnsorted;
        nulSigBinCountUnsorted = tmpNullSigCount + nulSigBinCountUnsorted;
      elseif unit_ind == unitLen
        sigBinCountMUA = tmpSigCount + sigBinCountMUA;
        nulSigBinCountMUA = tmpNullSigCount + nulSigBinCountMUA;
      else
        totalUnitCount = totalUnitCount + 1;
        sigBinCountUnit = tmpSigCount + sigBinCountUnit;
        nulSigBinCountUnit = tmpNullSigCount +nulSigBinCountUnit;
        sigBinCountTotal = [sigBinCountTotal; sum(tmpSigCount)];
        % Keep count of consecutive bins for units
        for targ_i = 1:size(tmpSigCount,2)
          starts = find(diff([0; tmpSigCount(:,targ_i)]) == 1);
          ends = find(diff([tmpSigCount(:,targ_i); 0]) == -1)+1;
          runLengths = ends - starts;
          targetRunLengths.(target{targ_i}) = [targetRunLengths.(target{targ_i}); runLengths];
        end
      end
    end
  end
end

% Plot Results
% Fig 1 - Soc vs Non-Soc significance bins
target = {'socialInteraction','agents','interaction'};
allUnitTraces = [sigBinCountUnit, nulSigBinCountUnit];
allMUATraces = [sigBinCountMUA, nulSigBinCountMUA];
allUnsortedTraces = [sigBinCountUnsorted,nulSigBinCountUnsorted];
legendCells = cell(length(target)*2,1);
for legend_i = 1:length(target)
  legendCells{legend_i} = target{legend_i};
  legendCells{legend_i+length(target)} = ['Label scramble ' target{legend_i}];
end

figure
subplot(3,1,1)
plot(allUnitTraces,'Linewidth',3);
legend(legendCells);
ylim([0 totalUnitCount/5]);
xlim([0 length(allUnitTraces)])
title('Significant Units per Bin')
subplot(3,1,2)
plot(allMUATraces,'Linewidth',3);
legend(legendCells);
ylim([0 totalUnitCount/5]);
xlim([0 length(allUnitTraces)])
title('Significant MUA per Bin')
subplot(3,1,3)
plot(allUnsortedTraces,'Linewidth',3);
legend(legendCells);
ylim([0 totalUnitCount/5]);
xlim([0 length(allUnitTraces)])
title('Significant Unsorted per Bin')

% Fig 2 - Numbers of bins per stimuli, length of stretches
figure()
for ii = 1:length(target)
  %Plot significant bin count per unit
  subplot(length(target), 2, (ii*2)-1)
  histogram(sigBinCountTotal(:,ii),50)
  title(sprintf('Number of bins per unit (%s)',target{ii}))
  %Plot stretch duration per unit
  subplot(length(target), 2, (ii * 2))
  histogram(targetRunLengths.(target{ii}))
  title(sprintf('Length of significant bin runs per unit (%s)',target{ii}))
end

% Fig 3 - Plot Omega curves, save to Run folder.
allMaxOmegas = [];
figData.binSize = binSize; %figData required to save figure.
figData.binStep = binStep;
for run_ind = 1:length(runList)
  omegaVec = spikeDataBank.(runList{run_ind}).omegaVec;
  for chan_ind = 1:length(omegaVec)
    for unit_ind = 1:length(omegaVec{chan_ind})
      if unit_ind == 1
        ANOVAvarName = ['Ch' num2str(chan_ind) ' Unsorted'];
      elseif unit_ind == length(omegaVec{chan_ind})
        ANOVAvarName = ['Ch' num2str(chan_ind) ' MUA'];
      else
        ANOVAvarName = ['Ch' num2str(chan_ind) ' unit ' num2str(unit_ind-1)];
        allMaxOmegas = [allMaxOmegas; spikeDataBank.(runList{run_ind}).maxOmegaVec{chan_ind}{unit_ind}];
      end
      figure()
      plot(omegaVec{chan_ind}{unit_ind},'linewidth',2)
      hold on
      xlim([0,size(omegaVec{chan_ind}{unit_ind},1)]);
      ylim([0,0.2]);
      title(sprintf('Sliding Window ANOVA Omega - %s, %d ms bin', ANOVAvarName, binSize))
      for leg_ind = 1:length(target)
        legendText{leg_ind} = sprintf('%s', target{leg_ind});
      end
      legend(legendText);
      starts = spikeDataBank.(runList{run_ind}).epochs(:,1);
      xticks(1:10:length(starts))
      xticklabels(starts(1:10:length(starts)));
      fileName = sprintf('Omega Curve - %s, %d ms bins, %d ms step', ANOVAvarName, binSize, binStep);
      savePath = [spikeDataBank.(runList{run_ind}).figDir filesep];
      saveFigure(savePath, fileName, figData, 1, 0, 0, runList{run_ind}, 'close')
    end
  end
end

%Distribution of peak sensitivities 
for ii = 1:size(allMaxOmegas,2)
  figure
  hist(allMaxOmegas(:,ii),20);
  title(target{ii});
end

end

function spikeDataBank = frameFiringRates(spikeDataBank,params)
% Generates means and distributions based on what is being looking at.

% Generate variables needed
runList = fields(spikeDataBank);

% Step 1 - generate bin times and spike rates, and proper memberships to groups.
% if 1%~isfield(spikeDataBank.(runList{1}), 'epochRates')
%   for run_ind = 1:length(runList)
%     runStruct = spikeDataBank.(runList{run_ind});
%     starts = (runStruct.start:binStep:(runStruct.end - binSize))';
%     ends = (runStruct.start+binSize:binStep:(runStruct.end))';
%     spikeDataBank.(runList{run_ind}).epochs = [starts,ends];
%     spikeDataBank.(runList{run_ind}).epochRates = cell(length(starts),1);
%     for bin_ind = 1:length(starts)
%       [spikeDataBank.(runList{run_ind}).epochRates{bin_ind}, ~, ~] = spikeCounter(spikeDataBank.(runList{run_ind}).spikesByEvent, starts(bin_ind), ends(bin_ind));
%     end
%     for group_ind = 1:length(target)
%       groupDef = target{group_ind};
%       nestStrCmp = @(x) any(strcmp(x, groupDef));
%       spikeDataBank.(runList{run_ind}).catagoryInd(:,group_ind) = cell2mat(cellfun(nestStrCmp, runStruct.eventCategories,'UniformOutput',0));
%     end
%   end
%   saveSpikeDataBank(spikeDataBank, 5, 'save',params.outputDir);
% else
%   fprintf('Sliding windows rates already calculated, continuing... \n');
% end


% Step 2 - Perform ANOVA, Omega calculation, and store values.
% performs an ANOVA on rates across a trial, starting at trial time 0, in some predefined steps.
plotCells = 0;
depth = 2;
for run_ind = 1:length(runList)
  % Check if pValues have already been recorded for this run.
  if ~isfield(spikeDataBank.(runList{length(run_ind)}),'pVec')
    % Initialize relevant Structures
    [pVec, nullVec] = deal(initNestedCellArray(spikeDataBank.(runList{run_ind}).epochRates{1}, 'ones', [length(spikeDataBank.(runList{run_ind}).epochs), length(target)], depth)); % Initialize each p value array.
    omegaVec = initNestedCellArray(spikeDataBank.(runList{run_ind}).epochRates{1}, 'zeros', [length(spikeDataBank.(runList{run_ind}).epochs), length(target)], depth);
    %[maxOmegaVec] = deal(initNestedCellArray(spikeDataBank.(runList{run_ind}).epochRates{1}, 'zeros', [1, length(target)], depth)); % Initialize each p value array.
    if length(unique(spikeDataBank.(runList{run_ind}).catagoryInd)) > 1 %Only run tests where you have members in each group.
      for bin_ind = 1:length(spikeDataBank.(runList{run_ind}).epochs)
        for chan_ind = 1:length(spikeDataBank.(runList{run_ind}).epochRates{bin_ind})
          for unit_ind = 1:length(spikeDataBank.(runList{run_ind}).epochRates{bin_ind}{chan_ind})
            unitResponsePerEvent = spikeDataBank.(runList{run_ind}).epochRates{bin_ind}{chan_ind}{unit_ind};
            catagortyInd = spikeDataBank.(runList{run_ind}).catagoryInd;
            %unitData{event}.rates = trial*1
            for target_ind = 1:length(target)
              if length(unique(catagortyInd(:,target_ind))) == 1
                break % If there is only 1 label type, there is no comparison to be made.
              end
              [trialSpikes, trialLabels]  = deal([]);
              % grab the relevant events
              targetInd = catagortyInd(:,target_ind);
              targetSpikes = unitResponsePerEvent(targetInd);
              otherSpikes = unitResponsePerEvent(~targetInd);
              % Initialize relevant vecotrs
              spikeGroups = {targetSpikes otherSpikes};
              spikeGroupLabels ={(target{target_ind}) (['non-' target{target_ind}])};
              % Cluster and reshape the arrays properly
              for group_i = 1:length(spikeGroups)
                tmp = spikeGroups{group_i};
                tmp = [tmp{:}];
                dataVec = vertcat(tmp.rates);
                labelVec = repmat(spikeGroupLabels(group_i), length(dataVec),1);
                trialSpikes = vertcat(trialSpikes,dataVec);
                trialLabels = vertcat(trialLabels, labelVec);
              end
              % Check for social v non-social
              [pVec{chan_ind}{unit_ind}(bin_ind,target_ind), pStatsTable, ~] = anovan(trialSpikes,{trialLabels},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
              top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
              bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
              omegaVec{chan_ind}{unit_ind}(bin_ind,target_ind) = top/bottom;
              [nullPVec, nullOmegaVec] = deal(zeros(1,100));
              for rand_ind = 1:50
                trialLabels = trialLabels(randperm(length(trialLabels)));
                [nullPVec(rand_ind), pStatsTable, ~] = anovan(trialSpikes,{trialLabels},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
                top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
                bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
                nullOmegaVec(rand_ind) = top/bottom;
              end
              nullVec{chan_ind}{unit_ind}(bin_ind,target_ind) = mean(nullPVec);
              % On the last bin, do the desired stimulus wide calculations
              % for collected traces.
%               if bin_ind == length(spikeDataBank.(runList{run_ind}).epochs)
%                 maxOmegaVec{chan_ind}{unit_ind} = max(omegaVec{chan_ind}{unit_ind});
%               end
            end
          end
        end
      end
    else
      disp('Skipping')
    end
    spikeDataBank.(runList{run_ind}).pVec = pVec;
    spikeDataBank.(runList{run_ind}).nullPVec = nullVec;
%     spikeDataBank.(runList{run_ind}).maxOmegaVec = maxOmegaVec;
    spikeDataBank.(runList{run_ind}).omegaVec = omegaVec;
    % Plot the results for each unit seen
    if plotCells
      for chan_ind = 1:length(pVec)
        for unit_ind = 1:length(pVec{chan_ind})
          if unit_ind == 1
            ANOVAvarName = ['Ch' num2str(chan_ind) ' Unsorted - SocVsNonSoc'];
          elseif unit_ind == length(pVec{chan_ind})
            ANOVAvarName = ['Ch' num2str(chan_ind) ' MUA - SocVsNonSoc'];
          else
            ANOVAvarName = ['Ch' num2str(chan_ind) ' U' num2str(unit_ind-1) ' - SocVsNonSoc'];
          end
          figure()
          plot(pVec{chan_ind}{unit_ind},'linewidth',2)
          hold on
          xlim([0,size(pVec{chan_ind}{unit_ind},1)]);
          ylim([0,1]);
          plot([0,size(pVec{chan_ind}{unit_ind},1)],[0.05, 0.05],'k','linewidth',3)
          title(sprintf('Sliding Scale ANOVA - %s',ANOVAvarName))
          fracSig = round(sum(pVec{chan_ind}{unit_ind} < 0.05)/length(pVec{chan_ind}{unit_ind}), 3, 'significant');
          fragSigNull = round(sum(pVec{chan_ind}{unit_ind} < 0.4)/length(pVec{chan_ind}{unit_ind}), 3, 'significant');
          for leg_ind = 1:length(target)
            legendText{leg_ind} = sprintf('%s (%s;%s)', target{leg_ind}, num2str(fracSig(leg_ind)),num2str(fragSigNull(leg_ind)));
          end
          for null_ind = 1:length(target)
            h.(sprintf('NullLine%d', null_ind)) = mseb(1:length(nullVec{chan_ind}{unit_ind}),nullVec{chan_ind}{unit_ind}(:,null_ind)', errVec{chan_ind}{unit_ind}(:,null_ind)');
            h.(sprintf('NullLine%d', null_ind)).patch.FaceAlpha = '0.5';
          end
          legend(legendText);
        end
      end
    end
    % Every 20 runs, save progress back to the files
    if mod(run_ind,20) == 0 || run_ind == length(runList)
      disp(run_ind)
      saveSpikeDataBank(spikeDataBank, 5, 'save',params.outputDir);
    end
  else
    sprintf('spikeDataBank field already has pVec, moving to next field... \n')
  end
end
sprintf('ANOVA Omega Calculations finished... \n')

% Count Results of ANOVA across all units, count stretches of significant
% bins.
totalUnitCount = 0;
totalChannelCount = 0;
[sigBinCountUnit, sigBinCountUnsorted, sigBinCountMUA, ...
  nulSigBinCountUnit, nulSigBinCountUnsorted, nulSigBinCountMUA] = deal(zeros(length(spikeDataBank.(runList{1}).epochs), length(target)));
sigBinCountTotal = [];
targetRunLengths = struct();
for targ_i = 1:length(target)
  targetRunLengths.(target{targ_i}) = [];
end

for run_ind = 1:length(runList)
  for chan_ind = 1:length(spikeDataBank.(runList{run_ind}).pVec)
    totalChannelCount = totalChannelCount + 1;
    for unit_ind = 1:length(spikeDataBank.(runList{run_ind}).pVec{chan_ind})
      unitLen = length(spikeDataBank.(runList{run_ind}).pVec{chan_ind});
      uPVec = spikeDataBank.(runList{run_ind}).pVec{chan_ind}{unit_ind};
      uNullVec =  spikeDataBank.(runList{run_ind}).nullPVec{chan_ind}{unit_ind};
      % Check for significant bins
      tmpSigCount = uPVec < 0.05;
      tmpNullSigCount = uNullVec < 0.05;
      % Add to relevant structures
      if unit_ind == 1
        sigBinCountUnsorted = tmpSigCount + sigBinCountUnsorted;
        nulSigBinCountUnsorted = tmpNullSigCount + nulSigBinCountUnsorted;
      elseif unit_ind == unitLen
        sigBinCountMUA = tmpSigCount + sigBinCountMUA;
        nulSigBinCountMUA = tmpNullSigCount + nulSigBinCountMUA;
      else
        totalUnitCount = totalUnitCount + 1;
        sigBinCountUnit = tmpSigCount + sigBinCountUnit;
        nulSigBinCountUnit = tmpNullSigCount +nulSigBinCountUnit;
        sigBinCountTotal = [sigBinCountTotal; sum(tmpSigCount)];
        % Keep count of consecutive bins for units
        for targ_i = 1:size(tmpSigCount,2)
          starts = find(diff([0; tmpSigCount(:,targ_i)]) == 1);
          ends = find(diff([tmpSigCount(:,targ_i); 0]) == -1)+1;
          runLengths = ends - starts;
          targetRunLengths.(target{targ_i}) = [targetRunLengths.(target{targ_i}); runLengths];
        end
      end
    end
  end
end

% Plot Results
% Fig 1 - Soc vs Non-Soc significance bins
target = {'socialInteraction','agents','interaction'};
allUnitTraces = [sigBinCountUnit, nulSigBinCountUnit];
allMUATraces = [sigBinCountMUA, nulSigBinCountMUA];
allUnsortedTraces = [sigBinCountUnsorted,nulSigBinCountUnsorted];
legendCells = cell(length(target)*2,1);
for legend_i = 1:length(target)
  legendCells{legend_i} = target{legend_i};
  legendCells{legend_i+length(target)} = ['Label scramble ' target{legend_i}];
end

figure
subplot(3,1,1)
plot(allUnitTraces,'Linewidth',3);
legend(legendCells);
ylim([0 totalUnitCount/5]);
xlim([0 length(allUnitTraces)])
title('Significant Units per Bin')
subplot(3,1,2)
plot(allMUATraces,'Linewidth',3);
legend(legendCells);
ylim([0 totalUnitCount/5]);
xlim([0 length(allUnitTraces)])
title('Significant MUA per Bin')
subplot(3,1,3)
plot(allUnsortedTraces,'Linewidth',3);
legend(legendCells);
ylim([0 totalUnitCount/5]);
xlim([0 length(allUnitTraces)])
title('Significant Unsorted per Bin')

% Fig 2 - Numbers of bins per stimuli, length of stretches
figure()
for ii = 1:length(target)
  %Plot significant bin count per unit
  subplot(length(target), 2, (ii*2)-1)
  histogram(sigBinCountTotal(:,ii),50)
  title(sprintf('Number of bins per unit (%s)',target{ii}))
  %Plot stretch duration per unit
  subplot(length(target), 2, (ii * 2))
  histogram(targetRunLengths.(target{ii}))
  title(sprintf('Length of significant bin runs per unit (%s)',target{ii}))
end

% Fig 3 - Plot Omega curves, save to Run folder.
allMaxOmegas = [];
figData.binSize = binSize; %figData required to save figure.
figData.binStep = binStep;
for run_ind = 1:length(runList)
  omegaVec = spikeDataBank.(runList{run_ind}).omegaVec;
  for chan_ind = 1:length(omegaVec)
    for unit_ind = 1:length(omegaVec{chan_ind})
      if unit_ind == 1
        ANOVAvarName = ['Ch' num2str(chan_ind) ' Unsorted'];
      elseif unit_ind == length(omegaVec{chan_ind})
        ANOVAvarName = ['Ch' num2str(chan_ind) ' MUA'];
      else
        ANOVAvarName = ['Ch' num2str(chan_ind) ' unit ' num2str(unit_ind-1)];
        allMaxOmegas = [allMaxOmegas; spikeDataBank.(runList{run_ind}).maxOmegaVec{chan_ind}{unit_ind}];
      end
      figure()
      plot(omegaVec{chan_ind}{unit_ind},'linewidth',2)
      hold on
      xlim([0,size(omegaVec{chan_ind}{unit_ind},1)]);
      ylim([0,0.2]);
      title(sprintf('Sliding Window ANOVA Omega - %s, %d ms bin', ANOVAvarName, binSize))
      for leg_ind = 1:length(target)
        legendText{leg_ind} = sprintf('%s', target{leg_ind});
      end
      legend(legendText);
      starts = spikeDataBank.(runList{run_ind}).epochs(:,1);
      xticks(1:10:length(starts))
      xticklabels(starts(1:10:length(starts)));
      fileName = sprintf('Omega Curve - %s, %d ms bins, %d ms step', ANOVAvarName, binSize, binStep);
      savePath = [spikeDataBank.(runList{run_ind}).figDir filesep];
      saveFigure(savePath, fileName, figData, 1, 0, 0, runList{run_ind}, 'close')
    end
  end
end

%Distribution of peak sensitivities 
for ii = 1:size(allMaxOmegas,2)
  figure
  hist(allMaxOmegas(:,ii),20);
  title(target{ii});
end

end