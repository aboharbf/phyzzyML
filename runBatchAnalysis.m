function [analysisOutFilename] = runBatchAnalysis(inputs)
%%Unpack Inputs
analysisLog = struct();
load(inputs{1})   % Non spike variables, including path to spikes.
spikeDataBank = saveSpikeDataBank([], [], 'load', outputDir); %Spike variables

%Overwrite switches with what is currently in file
load(fullfile(outputDir, 'batchAnalysisParams.mat'));

%% Analyses
runList = fields(spikeDataBank);

if ~isfield(spikeDataBank.(runList{end}), 'stimPresCount')
  spikeDataBank = stimulusStatistics(spikeDataBank);
  %Save modified struct.
  saveEnv()
end

if plotSwitch.stimPresCount
  disp('plot stimPresCount')
  %Plot as an image the 'daysSinceLastPres' matrix, stimuli on Y, date on
  %X.will likely require a figure callback for making Y axis labels
  %legible.
  %At the top of the plot, I will have a single vector with 'days since
  %last recording' to highlight days after long breaks.
end

if ~exist('unitCounts','var')
  [trueCellInd, trueCellInfo, unitCounts] = trueCellCount(cellCountParams.batchRunxls, cellCountParams.recordingLogxls);
  for run_ind = 1:length(runList)
    sessionName = extractBetween(runList{run_ind}, 2, length(runList{run_ind}));
    dataInd = (strcmp(sessionName,trueCellInfo(:,1)));
    spikeDataBank.(runList{run_ind}).gridHoles  = trueCellInfo(dataInd, 2);
    spikeDataBank.(runList{run_ind}).recDepth  = trueCellInfo(dataInd, 3);
  end
  saveEnv()
end


% Remove repeated Runs
if ~calcSwitch.excludeRepeats && isfield(analysisLog, 'repeatsExcluded')
  error('Repeats already excluded in this spikeDataBank, delete and restart or change parameters')
elseif calcSwitch.excludeRepeats && ~isfield(analysisLog, 'repeatsExcluded')
  % Exclude repeated recordings at the same site.
  for run_ind = 1:length(runList)
    sessionName = extractBetween(runList{run_ind}, 2, length(runList{run_ind}));
    validInd = trueCellInd(strcmp(sessionName,trueCellInfo(:,1)));
    if sum(validInd) == 0
      % Remove entire field if all channels are repeated recordings.
      spikeDataBank = rmfield(spikeDataBank,(runList{run_ind}));
    else
      for event_ind = 1:length(spikeDataBank.(runList{run_ind}).spikesByEvent)
        % Remove individual channel info where one of the channels is
        % recording new units.
        spikeDataBank.(runList{run_ind}).spikesByEvent{event_ind} = spikeDataBank.(runList{run_ind}).spikesByEvent{event_ind}(validInd);
      end
      spikeDataBank.(runList{run_ind}).gridHoles(validInd) = spikeDataBank.(runList{run_ind}).gridHoles(validInd);
      spikeDataBank.(runList{run_ind}).recDepth(validInd) = spikeDataBank.(runList{run_ind}).recDepth(validInd);
    end
  end
  %Save modified struct.
  runListIndex = unitCounts.Exclude;
  analysisLog.repeatsExcluded = 1;
  saveEnv()
else
  runListIndex = unitCounts.nonExclude;
end

%% Combine PSTH across all runs for a particular stimulus.

%This will crash if the PSTHs aren't the same length.
if plotSwitch.meanPSTH && ~exist('meanPSTHStruct','var')
  [stimPSTH, meanPSTHStruct] = meanPSTH(spikeDataBank, meanPSTHParams);
  %saveEnv()
end

%% Gather information on frame rates
if plotSwitch.frameFiringRates && ~exist('frameFiringStruct','var')
  [spikeDataBank, frameFiringStruct] = frameFiringRates(spikeDataBank, frameFiringParams);
  saveEnv()
end

%% Check whether the novelty of the runs
if plotSwitch.novelty
  assert(logical(exist('meanPSTHStruct','var')), 'Must run w/ meanPSTH enabled for novelty analysis');
  spikeDataBank = noveltyAnalysis(spikeDataBank, stimPSTH, meanPSTHStruct,[], noveltyParams);
end

%% Perform sliding window ANOVA and Omega calculations
if plotSwitch.slidingWindowANOVA % && ~isfield(spikeDataBank, [Some new field generated by function])
  spikeDataBank = slidingWindowANOVA(spikeDataBank, slidingANOVAParams);
  saveEnv()
end

end

%% Functions

function spikeDataBank = stimulusStatistics(spikeDataBank)
% Stimuli Presentation count and 'Novelty' Related Information.
%Code below creates a single large vector of stimuli used, and uses this to
%create individual vectors containing which viewing of the stimulus this
%represent (i.e. 'this run represents the 10th viewing of X.avi'). It also
%appends a dateTime vector to each structure related to how long since the
%last recording day.

runList = fields(spikeDataBank);

%extract the eventIDs field, generate a cell array of unique stimuli
allStimuliVec = struct2cell(structfun(@(x) x.eventIDs, spikeDataBank,'UniformOutput', 0));
allStimuliVec = unique(vertcat(allStimuliVec{:}));

%Produce matrix (N stim * M runs) which gives 0 for non present stim, count of stim presentation otherwise.
stimLogicalArray = zeros(length(allStimuliVec),length(runList));
for run_ind = 1:length(runList)
  stimLogicalArray(:,run_ind) = ismember(allStimuliVec,spikeDataBank.(runList{run_ind}).eventIDs);
end
csStimLogicalArray = cumsum(stimLogicalArray,2);
csStimLogicalArray(~stimLogicalArray) = 0;

% When was a stimulus first seen? Index of runList where first presentation took place.
firstStimPresInd = zeros(length(allStimuliVec),1);
for stim_ind = 1:length(allStimuliVec)
  firstStimPresInd(stim_ind) = find(stimLogicalArray(stim_ind,:),1,'first');
end

% Append a dateTime to each field with the time in days since the last
% recording. Add the relevant slice of the larger csStimLogicalArray.
for run_ind = 1:length(runList)
  spikeDataBank.(runList{run_ind}).stimPresArray = csStimLogicalArray(:,run_ind);
  spikeDataBank.(runList{run_ind}).dateTime = datetime(extractBetween(spikeDataBank.(runList{run_ind}).dateSubject,1,8),'InputFormat','yyyyMMdd');     %Generate 'daysSinceLastRec' for each field.
end

% find unique recording dates, and the distance between them. Add these
% to the spikeDataBank
allDateTimeVec = struct2cell(structfun(@(x) x.dateTime, spikeDataBank,'UniformOutput', 0));
allDateTimeVec = [allDateTimeVec{:}]';
uniqueDateTimeVec = unique(allDateTimeVec);
daysSinceLastRec = [1000; days(diff(uniqueDateTimeVec))];
for run_ind = 1:length(runList)
  spikeDataBank.(runList{run_ind}).daysSinceLastRec = daysSinceLastRec(spikeDataBank.(runList{run_ind}).dateTime == uniqueDateTimeVec);
end

% use the dateTime and stimulus presentation matrix to find out how long
% in days takes place before a particular showing of a stimulus.
daysSinceLastPres = zeros(size(stimLogicalArray));
for stim_ind = 1:size(stimLogicalArray,1)
  presentationInd = logical(stimLogicalArray(stim_ind,:)); %When was the stim shown
  daysSinceLastPres(stim_ind,presentationInd) = [1000; days(diff(allDateTimeVec(presentationInd)))]; %Duration between those dates in days
end

%Return days since last presentation and the stimulus presentation count to spikeDataBank, arranged in way that matches stim table.
for run_ind = 1:size(stimLogicalArray,2)
  [~, big2SmallInd] = ismember(spikeDataBank.(runList{run_ind}).eventIDs,allStimuliVec);
  spikeDataBank.(runList{run_ind}).daysSinceLastPres = daysSinceLastPres(big2SmallInd,run_ind);
  spikeDataBank.(runList{run_ind}).stimPresCount = csStimLogicalArray(big2SmallInd,run_ind);
end

end

function [stimPSTH, meanPSTHStruct] = meanPSTH(spikeDataBank, params)
% Function which combines stimulus presentations across all runs in the spikeDataBank.
% Inputs include spikeDataBank and list of parameters.
disp('Starting mean PSTH Analysis...');
exportFig = params.exportFig;

% Rebuild variables
% extract the eventIDs field, generate a cell array of unique stimuli
allStimuliVec = struct2cell(structfun(@(x) x.eventIDs, spikeDataBank,'UniformOutput', 0));
allStimuliVec = unique(vertcat(allStimuliVec{:}));

% Generate grid for indexing into individual runs and extracting relevant
% PSTHes.
runList = fields(spikeDataBank);
small2BigInd = zeros(length(allStimuliVec), length(runList));
for run_ind = 1:length(runList)
  [~, small2BigInd(:,run_ind)] = ismember(allStimuliVec, spikeDataBank.(runList{run_ind}).eventIDs);
end

stimPresCounts = sum(logical(small2BigInd),2);

% If you only want stim above a certain count, remove here.
if params.plotTopStim
  keepInd = stimPresCounts >= params.topStimPresThreshold;
  stimPresCounts = stimPresCounts(keepInd);
  small2BigInd = small2BigInd(keepInd,:);
  allStimuliVec = allStimuliVec(keepInd,:);
end

animParam.stimParamsFilename = params.stimParamsFilename;
animParam.plotLabels = {'animSocialInteraction', 'animControl'};
[tmp, ~, ~] = plotIndex(allStimuliVec, animParam);
animInd = logical(sum(tmp,2));

%Generate the reward directory
dirTags = {'without Rewards','fixAligned','Normalized','Pres Threshold'};
dirTagSwitch = [params.removeRewardEpoch, params.fixAlign, params.normalize, params.plotTopStim];
params.outputDir = [params.outputDir strjoin(dirTags(logical(dirTagSwitch)),' - ')];

if params.stimInclude == 1
  stimPresCounts = stimPresCounts(animInd);
  small2BigInd = small2BigInd(animInd,:);
  allStimuliVec = allStimuliVec(animInd,:);
  params.outputDir = [params.outputDir '- AnimOnly'];
elseif params.stimInclude == 2
  stimPresCounts = stimPresCounts(~animInd);
  small2BigInd = small2BigInd(~animInd,:);
  allStimuliVec = allStimuliVec(~animInd,:);
  params.outputDir = [params.outputDir '- NoAnim'];
end

[plotMat, briefStimList, params] = plotIndex(allStimuliVec, params);

if params.normalize
  normTag = ' - normalized';
else
  normTag = '';
end

if ~exist(params.outputDir, 'dir')
  mkdir(params.outputDir)
end

% Step 1 - Concatonate PSTHs - iterate across stimuli, grab PSTHes from each run, store
groupingType = {'Unsorted', 'Units', 'MUA'};
dataType = {'PSTH', 'PSTH Err', 'presCount','daysSinceLastPres', 'daysSinceLastRec', 'Run of Day', 'Grid Hole', 'Recording Depth', 'Run Ind'};
% {'Run of Day', 'Grid Hole', 'Run of Day', 'Recording Depth'};

meanPSTHStruct = struct();
meanPSTHStruct.IndStructs{1} = allStimuliVec;
meanPSTHStruct.IndStructs{2} = groupingType;
meanPSTHStruct.IndStructs{3} = dataType;
%stimPSTH{stim,grouping,dataType}
stimPSTH = cell([length(allStimuliVec), length(groupingType), length(dataType)]);
rewardStart = abs(spikeDataBank.(runList{1}).start) + spikeDataBank.(runList{1}).stimDur;

totalPopCount = 0;
maxAct = [];

for stim_ind = 1:length(allStimuliVec)
  % Find the runs where the stimulus was present, generate a list of them.
  stimRunIndex = small2BigInd(stim_ind,:);
  psthStimIndex = nonzeros(stimRunIndex);
  psthRunIndex = find(stimRunIndex);
  subRunList = runList(psthRunIndex);
  
  % For all runs containing a particular stimuli, retrieve relevant activity vector in each.
  for subRun_ind = 1:length(subRunList)
    tmpRunStruct = spikeDataBank.(subRunList{subRun_ind});
    for chan_ind = 1:length(tmpRunStruct.psthByImage)
      for unit_ind = 1:length(tmpRunStruct.psthByImage{chan_ind})
        % Retrieve correct PSTH from run
        unitActivity = tmpRunStruct.psthByImage{chan_ind}{unit_ind}(psthStimIndex(subRun_ind),:);
        unitErr = tmpRunStruct.psthErrByImage{chan_ind}{unit_ind}(psthStimIndex(subRun_ind),:);
        
        if sum(unitActivity) < 3
          continue
        end
        
        if params.removeRewardEpoch
          unitActivity = unitActivity(1:rewardStart);
          unitErr = unitErr(1:rewardStart);
          params.psthPost = 0;
        end
        presCount = tmpRunStruct.stimPresCount(psthStimIndex(subRun_ind));
        gridHole = tmpRunStruct.gridHoles;
        depth = tmpRunStruct.recDepth;
        assert(length(gridHole) == length(depth), 'F');
        
        daysSinceLastPres = tmpRunStruct.daysSinceLastPres(psthStimIndex(subRun_ind));
        daysSinceLastRec = tmpRunStruct.daysSinceLastRec;
        % If desired, Z score PSTHs here based on fixation period activity.
        if params.normalize
          tmp = tmpRunStruct.psthByImage{chan_ind}{unit_ind}(:,1:abs(tmpRunStruct.start));
          tmp = reshape(tmp, [size(tmp,1) * size(tmp,2), 1]);
          fixMean = mean(tmp); %Find activity during fixation across all stim.
          if params.normalize == 1
            fixSD = std(tmp);
            unitActivity = ((unitActivity - fixMean)/fixSD);
            unitErr = ((unitErr - fixMean)/fixSD);
          end
        end
        % Store the generated values into a dataArray
        dataArray = cell(length(dataType),1); % Structure to store and iterate across.
        % dataType = {'PSTH', 'PSTH Err', 'presCount','daysSinceLastPres', 'daysSinceLastRec', 'Run of Day', 'Grid Hole', 'Recording Depth', 'Run Ind'};
        dataArray{1} = unitActivity;
        dataArray{2} = unitErr;
        dataArray{3} = presCount;
        dataArray{4} = daysSinceLastPres;
        dataArray{5} = daysSinceLastRec;
        dataArray{6} = str2double(tmpRunStruct.runNum);
        dataArray{7} = {num2str(gridHole{chan_ind})};
        dataArray{8} = depth{chan_ind};
        dataArray{9} = psthRunIndex(subRun_ind);
                
        % Concatonate to the correct Matrix (index matching phyzzy convention)
        if unit_ind == 1 % Unsorted
          groupInd = 1;
        elseif unit_ind == length(tmpRunStruct.psthByImage{chan_ind}) % MUA
          groupInd = 3;
        else % Unit
          groupInd = 2;
        end
        for data_ind = 1:length(dataArray)
          stimPSTH{stim_ind,groupInd,data_ind} = [stimPSTH{stim_ind,groupInd,data_ind}; dataArray{data_ind}];
        end
      end
    end
  end
end

% Step 2 - Plot 
allStimuliNames = cellfun(@(x) extractBetween(x, 1, length(x)-4), allStimuliVec);

if params.plotTest
% Generate needed indicies and structures for plotting.
stimPresMat = cellfun(@(x) size(x,1),stimPSTH(:,:,end));
meanPSTHStruct.stimPresMat = stimPresMat;
broadLabelInd = logical(plotMat);
dataInd2Plot = 1:2;

for broad_ind = 1:length(params.plotLabels)
  % Extract relevant slices of larger matricies
  sliceStimPSTH = stimPSTH(broadLabelInd(:,broad_ind),:,dataInd2Plot);
  sliceStimLabels = briefStimList(broadLabelInd(:,broad_ind));
  sliceStimPresMat = stimPresMat(broadLabelInd(:,broad_ind),:);
  
  % Generate a matrix of the meanPSTHes, with the last row being total
  % means. Add this to the counts as well.
  meanPSTH = cellfun(@(x) mean(x),sliceStimPSTH,'UniformOutput',0);
  catMeanMat = cell(1,size(sliceStimPSTH,2),size(sliceStimPSTH,3));
  catErrMat = cell(1,size(sliceStimPSTH,2),size(sliceStimPSTH,3));
  for group_ind = 1:length(groupingType)
    for data_ind = dataInd2Plot
      tmp = vertcat(sliceStimPSTH{:,group_ind,data_ind});
      catMeanMat{1,group_ind,data_ind} = mean(tmp,1);
      catErrMat{1,group_ind,data_ind} = std(tmp)/sqrt(size(tmp,1));
    end
  end
  meanPSTH = cat(1, meanPSTH, catMeanMat);
  
  sliceStimPresMat = [sliceStimPresMat; sum(sliceStimPresMat, 1)];
  if iscell(params.plotLabels{broad_ind})
    params.plotLabels{broad_ind} = strjoin(params.plotLabels{broad_ind});
  end
  sliceStimLabels = [sliceStimLabels; params.plotLabels{broad_ind}];
  
  for group_ind = 1:length(groupingType)
    % Prepare labels
    stimLabels = cell(length(sliceStimLabels),1);
    for stim_ind = 1:length(stimLabels)
      stimLabels{stim_ind} = [sliceStimLabels{stim_ind} ',n = ' num2str(sliceStimPresMat(stim_ind,group_ind))];
    end
    
    % Extract correct data
    plotData = vertcat(meanPSTH{:,group_ind,1});
    
    % If Sorting data, do so here.
    if params.sortPresCount
      [~, newOrder] = sort(sliceStimPresMat(:,group_ind));
      plotLabels = stimLabels(newOrder);
      plotData = plotData(newOrder, :);
    else
      plotLabels = stimLabels;
    end
    
    psthTitle = sprintf('All %s Stimuli - Mean %s%s, %s', params.plotLabels{broad_ind}, dataType{1}, normTag, groupingType{group_ind});
    % Plot the Activity
    h = figure('NumberTitle', 'off', 'Name', psthTitle,'units','normalized','outerposition',[0 0 .8 .8]);
    [psthAxes, cbHandle] = plotPSTH(plotData, axes(), params, 'color', psthTitle, plotLabels);
    psthAxes.FontSize = 12;
    title(psthTitle)
    grandMeanAxes = axes('YAxisLocation','right','Color', 'none','xtick',[],'xticklabel',[],'xlim',[0 size(plotData,2)]);%,'ytick',[],'yticklabel',[]);
    grandMeanAxes.YAxis.FontSize = 12;
    hold on
    lineprops.col{1} = 'k';
    mseb(1:size(plotData,2), plotData(end,:), catErrMat{end,group_ind,2}, lineprops,1);
    linkprop([psthAxes, grandMeanAxes],{'Position'});
    if params.normalize == 1
      cbHandle.Label.String = 'Signal Change relative to Baseline (%)';
    elseif params.normalize == 2
      cbHandle.Label.String = 'Z scored relative to fixation';
    end
    cbHandle.Label.FontSize = 12;
    tmp = psthAxes.Position;
    cbHandle.Position(1) = cbHandle.Position(1) + .03;
    psthAxes.Position = tmp;
    
    saveFigure(params.outputDir, ['1.' psthTitle], [], 1, exportFig, 0, {''})
    close(h);  
  end
  
end


% Plot all Stimuli means in the same plot.
for group_ind = 1:size(stimPSTH,2)
  stimCounts = stimPresMat(:,group_ind);
  allStimuliLabel = cell(length(allStimuliNames),1);
  for stim_ind = 1:length(allStimuliNames)
    allStimuliLabel{stim_ind} = [allStimuliNames{stim_ind} ',n = ' num2str(stimCounts(stim_ind))];
  end
  groupData = stimPSTH(:, group_ind, 1);
  groupData = cellfun(@(x) mean(x, 1), groupData, 'UniformOutput',0);
  plotData = vertcat(groupData{:});
  
  if params.sortPresCount
    [~, newOrder] = sort(stimCounts);
    allStimuliLabel = allStimuliLabel(newOrder);
    plotData = plotData(newOrder, :);
  end
  
  catPSTHTitle = sprintf('%s Mean PSTH - All Stimuli, %s', groupingType{group_ind}, normTag);
  h = figure('NumberTitle', 'off', 'Name', catPSTHTitle);
  [catPSTHAxes, cbh] = plotPSTH(plotData, axes(), params, 'color', catPSTHTitle, allStimuliLabel);
  if params.normalize == 1
    ylabel('Normalized Activity (Baseline Z scored)');
    cbh.Label.String = 'Signal Change relative to Baseline (%)';
  elseif params.normalize == 2
    cbh.Label.String = 'Z scored relative to fixation';
    ylabel('Normalized Activity (Baseline Z scored)');
  else
    ylabel('Activity (Firing Rate)');
  end
  title(catPSTHTitle);
  xlabel('Time (ms)');
  saveFigure(params.outputDir, ['2.' catPSTHTitle], [], 1, exportFig, 0, {''})
  close(h)
  clear allStimuliLabel
end

end
% Make a PSTH of each stimulus across all its repetitions.
sortType = {'Run of Day', 'Grid Hole', 'Recording Depth', 'Run Ind'};
% {'Run of Day', 'Grid Hole', 'Recording Depth', 'Run Ind'};
% Must be the same order as the final parts of stimPSTH
sortMat = cell(size(stimPSTH,1), size(stimPSTH,2), length(sortType));
sortLabel = cell(size(stimPSTH,1), size(stimPSTH,2), length(sortType));

for stim_i = 1:size(stimPSTH,1)
  for group_i = 1:size(stimPSTH,2)
    for sort_i = 1:length(sortType) % the sortings that need processing
      
      if sort_i == 1 || sort_i == 2 
        % Store indicies in 1st, labels in 2nd %Grid Holes --> Indicies
        [tmpLabels , sortMat{stim_i, group_i, sort_i}] = sort(stimPSTH{stim_i, group_i,strcmp(dataType, sortType{sort_i})});
        
        % Generate Labeling index
        uniqueLabels = unique(tmpLabels);
        labeledIndex = zeros(length(uniqueLabels),1);
        for uni_i = 1:length(uniqueLabels)
          if sort_i == 1
            labeledIndex(uni_i) = find(tmpLabels == uniqueLabels(uni_i), 1);
          elseif sort_i == 2
            labeledIndex(uni_i) = find(strcmp(tmpLabels, uniqueLabels(uni_i)),1);
          end
        end 
        
      elseif sort_i == 3 %Recording Depth --> Indicies
        tmpDepths = [stimPSTH{stim_i, group_i,strcmp(dataType, sortType{sort_i})}];
        [tmpLabels , sortMat{stim_i, group_i, sort_i}] = sort(tmpDepths');
        labeledIndex = 1:5:length(tmpLabels);
        
      elseif sort_i == 4
        sortMat{stim_i, group_i, sort_i} = 1:length(stimPSTH{stim_i, group_i, strcmp(dataType, sortType{sort_i})});
        tmpLabels = runList(stimPSTH{stim_i, group_i,strcmp(dataType, sortType{sort_i})});
        labeledIndex = 1:5:length(tmpLabels);
      end
      
      % Use the labeledIndex to generate the proper label array with 0's
      % everywhere else.
      sortLabelTmp = cell(length(tmpLabels),1);
      for tmp_i = 1:length(labeledIndex)
        if sort_i == 2 || sort_i == 4
          sortLabelTmp{labeledIndex(tmp_i)} = tmpLabels{labeledIndex(tmp_i)};
        else
          sortLabelTmp{labeledIndex(tmp_i)} = tmpLabels(labeledIndex(tmp_i));
        end
      end
      sortLabel{stim_i, group_i, sort_i} = sortLabelTmp;

    end
  end
end

for stim_i = 1:length(stimPSTH)
  for sort_i = 4%1:length(sortType)
    figTitle = sprintf('%s - all PSTHs, Sorted by %s, %s', allStimuliNames{stim_i}, sortType{sort_i}, normTag);
    h = figure('NumberTitle', 'off', 'Name', figTitle,'units','normalized','outerposition',[0 0 1 1]);
    sgtitle(figTitle)
    
    for group_i = 1:size(stimPSTH,2)
      sortIndex = sortMat{stim_i, group_i, sort_i};
      plotLabels = sortLabel{stim_i, group_i, sort_i};
      plotData = stimPSTH{stim_i,group_i,1};
      psthAxes = subplot(1,3,group_i);
      [~, cbHandle] = plotPSTH(plotData(sortIndex,:), psthAxes, params, 'color', groupingType{group_i}, plotLabels);
      cbHandle.Label.FontSize = 12;
      if params.normalize == 1
        cbHandle.Label.String = 'Signal Change relative to Baseline (%)';
      elseif params.normalize == 2
        cbHandle.Label.String = 'Z score relative to fixation';
      end
      set(gca,'FontSize',10,'TickLength',[.01 .01],'LineWidth',.25);
    end
    saveFigure(params.outputDir, ['3.' figTitle], [], 1, exportFig, 0, {''})
    close(h)
  end
end


% Cross Catagory Line Plot
catCount = find(strcmp(params.plotLabels, 'scene'));
if isempty(catCount)
  catCount = find(strcmp(params.plotLabels, 'grooming'));
end

singleCatPlotMat = plotMat(:,1:catCount);
singleCatplotLabels = params.plotLabels(1:catCount);
tmp = distinguishable_colors(catCount);
plotColors = cell(catCount,1);
for col_i = 1:catCount
  plotColors{col_i} = tmp(col_i,:);
end

for group_ind = 1:size(stimPSTH,2)
  catPSTHTitle = sprintf('%s Mean PSTH %s', groupingType{group_ind}, normTag);
  h = figure('NumberTitle', 'off', 'Name', catPSTHTitle);
  hold on
  % Generate line plots w/ error bars.
  lineProps.width = 1;
  lineProps.col = plotColors;
  lineProps.patch.FaceAlpha = '0.5';
  
  [groupData, groupErr] = deal(cell(size(singleCatPlotMat,2),1));
  for cat_ind = 1:size(singleCatPlotMat,2)
    tmp = vertcat(stimPSTH{logical(singleCatPlotMat(:,cat_ind)), group_ind});
    groupData{cat_ind} = mean(tmp,1);
    groupErr{cat_ind} = std(tmp)/sqrt(size(tmp,1));
  end
  
  groupData = vertcat(groupData{:});
  
  if params.fixAlign
    groupMean = mean(mean(groupData(:,500:800)));
    for g_ind = 1:size(groupData,1)
      groupData(g_ind,:) = groupData(g_ind,:) - mean(groupData(g_ind,500:800)) + groupMean;
    end
  end
  
  mseb(-800:(size(groupData,2)-801),groupData, vertcat(groupErr{:}), lineProps);
  xlim([-800 (size(groupData,2)-801)])
  legend(singleCatplotLabels, 'AutoUpdate','off');
  line([0 0], ylim(), 'Linewidth',3,'color','k');
  line([2800 2800], ylim(), 'Linewidth',3,'color','k');
  xlabel('Time (ms)');
  ylabel('Normalized Activity (Baseline Z scored)');
  title(catPSTHTitle);
  saveFigure(params.outputDir, ['4.' catPSTHTitle], [], 1, exportFig, 0, {''})
  close(h)
end

% Generate line plots across different labeling schemes.
socialInd = logical(plotMat(:,strcmp(params.plotLabels,'socialInteraction')));
agentInd = logical(plotMat(:,strcmp(params.plotLabels,'agents')));
headTurnInd = logical(plotMat(:,strcmp(params.plotLabels,'headTurning')));

% Agent videos without head turning.
agentNHInd = agentInd;
agentNHInd(headTurnInd) = false;

% Social videos, Head turning vs Not
htSocialIndTmp = socialInd + headTurnInd;
socialHTInd = false(length(htSocialIndTmp), 1);
socialNonHTInd = false(length(htSocialIndTmp), 1);
socialHTInd(htSocialIndTmp == 2) = true;
socialNonHTInd = socialInd;
socialNonHTInd(headTurnInd) = false;

% Social Agent vs Non-Social Agent
socialAgentInd = socialInd;
nonSocialAgentInd = logical(agentInd-socialInd);

figIncInd = {agentInd, socialInd, headTurnInd, socialHTInd, socialAgentInd};
figExcInd = {~agentInd, ~socialInd, agentNHInd, socialNonHTInd, nonSocialAgentInd};
figTitInd = {'Agent vs Non Agent','Soc v Non Soc','Agents Head Turning v Agents Non Head Turning', 'Social Head turning vs Social Non-Head Turning', 'Social Agents vs Non-Social Agents'};
figLegends = {{'Agents','Non-Agent'},{'Social','Non Social'},{'Agents Head Turning','Agents Not Head Turning'},{'Social Agents Head Turning','Social Agents Not Head Turning'},{'Social Agents ','non-Social Agents'}};

for fig_ind = 1:length(figIncInd)
  line1Array = stimPSTH(figIncInd{fig_ind},:,1);
  line2Array = stimPSTH(figExcInd{fig_ind},:,1);
  if ~isempty(line1Array) && ~isempty(line2Array)
    for group_ind = 1:size(line1Array,2)
      % Generate Data
      line1Data = vertcat(line1Array{:,group_ind});
      line2Data = vertcat(line2Array{:,group_ind});
      lineMean = [mean(line1Data, 1); mean(line2Data, 1)];
      lineErr = [std(line1Data)/sqrt(size(line1Data,1)); std(line2Data)/sqrt(size(line2Data,1))];
      
      if params.fixAlign
        fixMean = mean(mean(lineMean(:,500:800),1));
        for line_i = 1:size(lineMean,1)
          lineMean(line_i,:) = lineMean(line_i,:) - mean(lineMean(line_i,500:800)) + fixMean;
        end
      end
      
      % Prepare figure
      plotTitle = sprintf('%s - %s, %s', figTitInd{fig_ind}, groupingType{group_ind}, normTag);
      h = figure('NumberTitle', 'off', 'Name', plotTitle);
      title(plotTitle)
      mseb((-800:size(lineMean,2)-801),lineMean, lineErr, []);
      legend(figLegends{fig_ind}, 'AutoUpdate','off')
      xlim([-800 (length(lineMean)-801)])
      line([0 0], ylim(), 'Linewidth',3,'color','k');
      line([2800 2800], ylim(), 'Linewidth',3,'color','k');
      xlabel('Time (ms)')
      ylabel('Normalized Activity')
      %       yL = ylim();
      %       if group_ind ~= 2
      %         ylim([-0.2, yL(2)])
      %       end
      saveFigure(params.outputDir, ['5.' plotTitle], [], 1, exportFig, 0, {''})
      close(h)
    end
  end
end

end

function spikeDataBank = slidingWindowANOVA(spikeDataBank,params)
disp('Starting sliding window ANOVA...');
% Perform sliding scale ANOVA, calculate Omega at each bin.

if ~exist(params.outputDir, 'dir')
  mkdir(params.outputDir)
end

% Generate variables needed
runList = fields(spikeDataBank);
binSize = params.binSize;
binStep = params.binStep;
target = params.target;
Omega = params.Omega;
stimParamFile = params.stimParamFile;
nestStrCmp = @(x, y) any(strcmp(x, y));

% Step 1 - for each bin (epoch), calculate the rates and counts. save them
% into a larger epochRates structure, which can be stored in the folder for
% this function for subsequent runs. 

if ~exist(fullfile(params.outputDir, 'epochRates.mat'), 'file')
  epochRates = cell(length(runList),1);
  catagoryInd = cell(length(runList),1);
  % Step 1 - generate bin times and spike rates, and proper memberships to groups.
  for run_ind = 1:length(runList)
    runStruct = spikeDataBank.(runList{run_ind});
    starts = (runStruct.start:binStep:(runStruct.end - binSize))';
    ends = (runStruct.start+binSize:binStep:(runStruct.end))';
    spikeDataBank.(runList{run_ind}).epochs = [starts,ends];
    epochRates{run_ind} = cell(length(starts),1);
    for bin_ind = 1:length(starts)
      [epochRates{run_ind}{bin_ind}, ~, ~] = spikeCounter(spikeDataBank.(runList{run_ind}).spikesByEvent, starts(bin_ind), ends(bin_ind));
    end
    for group_ind = 1:length(target)
      catagoryInd{run_ind}(:,group_ind) = cell2mat(cellfun(nestStrCmp, runStruct.eventCategories, repmat(target(group_ind), [length(runStruct.eventCategories),1]), 'UniformOutput',0));
    end
  end
  save(fullfile(params.outputDir, 'epochRates'), 'epochRates', 'catagoryInd');
else
  load(fullfile(params.outputDir, 'epochRates'), 'epochRates', 'catagoryInd');
  assert(length(epochRates) == length(runList), 'epochRates length does not match runList length');
  fprintf('Sliding windows rates already calculated, continuing... \n');
end

% Step 2 - Perform ANOVA, Omega calculation across bins, and store values.
% Save the output in the function folder for later retrieval. 

statsType = {'pVec', 'omegaVec', 'meanNullVec', 'meanErrVec' 'nullOmegaVec', 'maxNullOmegaVec'};

if ~exist(fullfile(params.outputDir, 'allStatsArray.mat'), 'file')
  chanUnitStruct = structfun(@(x) x.psthByImage, spikeDataBank,'UniformOutput',0);
  chanUnitStruct = struct2cell(chanUnitStruct);
  allStatsArray = initNestedCellArray(chanUnitStruct, 'NaN', [length(epochRates{1}), length(target), length(statsType)], 3);
  clear chanUnitStruct;
  scrambleCount = params.scrambleCount;
  
  tic
  if license('test','Distrib_Computing_Toolbox')
    
    epochRatesPar = parallel.pool.Constant(epochRates);
    catagoryIndPar =  parallel.pool.Constant(catagoryInd);
%     epochRatesPar.Value = epochRates;
%     catagoryIndPar.Value =  catagoryInd;
    parfor run_ind = 1:length(runList)
      % Initialize relevant Structures
      if length(unique(catagoryIndPar.Value{run_ind})) > 1 %Only run tests where you have members in each group.
        binCount = length(epochRatesPar.Value{run_ind});
        for chan_ind = 1:length(epochRatesPar.Value{run_ind}{1})
          for unit_ind = 1:length(epochRatesPar.Value{run_ind}{1}{chan_ind})
            for bin_ind = 1:binCount
              unitResponsePerEvent = epochRatesPar.Value{run_ind}{bin_ind}{chan_ind}{unit_ind};
              catagortyIndSlice = catagoryIndPar.Value{run_ind};
              %unitData{event}.rates = trial*1
              for target_ind = 1:length(target)
                if length(unique(catagortyIndSlice(:,target_ind))) == 1
                  break % If there is only 1 label type, there is no comparison to be made.
                end
                [trialSpikes, trialLabels]  = deal([]);
                % grab the relevant events
                targetInd = catagortyIndSlice(:,target_ind);
                targetSpikes = unitResponsePerEvent(targetInd);
                otherSpikes = unitResponsePerEvent(~targetInd);
                % Initialize relevant vecotrs
                spikeGroups = {targetSpikes otherSpikes};
                spikeGroupLabels ={(target{target_ind}) (['non-' target{target_ind}])};
                % Cluster and reshape the arrays properly
                for group_i = 1:length(spikeGroups)
                  tmp = spikeGroups{group_i};
                  tmp = [tmp{:}];
                  dataVec = vertcat(tmp.rates);
                  labelVec = repmat(spikeGroupLabels(group_i), length(dataVec),1);
                  trialSpikes = vertcat(trialSpikes,dataVec);
                  trialLabels = vertcat(trialLabels, labelVec);
                end
                % Check for social v non-social
                % 3rd ind in 3D mat statsType = {'pVec', 'omegaVec', 'meanNullVec', 'meanErrVec' 'nullOmegaVec', 'maxNullOmegaVec'};
                [allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('pVec',statsType)), pStatsTable, ~] = anovan(trialSpikes,{trialLabels},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
                top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
                bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('omegaVec',statsType)) = top/bottom;
                % Perform Calculations on scrambles
                [nullPVec, nullOmegaVecSingle] = deal(zeros(1,scrambleCount));
                for rand_ind = 1:scrambleCount
                  [nullPVec(rand_ind), pStatsTable, ~] = anovan(trialSpikes,{trialLabels(randperm(length(trialLabels)))},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
                  top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
                  bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
                  nullOmegaVecSingle(rand_ind) = top/bottom;
                end
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('meanNullVec',statsType)) = mean(nullPVec);
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('meanErrVec',statsType)) = std(nullPVec)/sqrt(length(nullPVec));
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('nullOmegaVec',statsType)) = mean(nullOmegaVecSingle);
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('maxNullOmegaVec',statsType)) = max(nullOmegaVecSingle);
              end
            end
          end
        end
      else
        disp('Skipping')
      end
    end
  else
    
    for run_ind = 1:length(runList)
      % Initialize relevant Structures
      if length(unique(catagoryInd{run_ind})) > 1 %Only run tests where you have members in each group.
        chanCount = length(epochRates{run_ind}{1});
        binCount = length(epochRates{run_ind});
        for chan_ind = 1:chanCount
          for unit_ind = 1:length(epochRates{run_ind}{1}{chan_ind})
            for bin_ind = 1:binCount
              unitResponsePerEvent = epochRates{run_ind}{bin_ind}{chan_ind}{unit_ind};
              catagortyIndSlice = catagoryInd{run_ind};
              %unitData{event}.rates = trial*1
              for target_ind = 1:length(target)
                if length(unique(catagortyIndSlice(:,target_ind))) == 1
                  break % If there is only 1 label type, there is no comparison to be made.
                end
                [trialSpikes, trialLabels]  = deal([]);
                % grab the relevant events
                targetInd = catagortyIndSlice(:,target_ind);
                targetSpikes = unitResponsePerEvent(targetInd);
                otherSpikes = unitResponsePerEvent(~targetInd);
                % Initialize relevant vecotrs
                spikeGroups = {targetSpikes otherSpikes};
                spikeGroupLabels ={(target{target_ind}) (['non-' target{target_ind}])};
                % Cluster and reshape the arrays properly
                for group_i = 1:length(spikeGroups)
                  tmp = spikeGroups{group_i};
                  tmp = [tmp{:}];
                  dataVec = vertcat(tmp.rates);
                  labelVec = repmat(spikeGroupLabels(group_i), length(dataVec),1);
                  trialSpikes = vertcat(trialSpikes,dataVec);
                  trialLabels = vertcat(trialLabels, labelVec);
                end
                % Check for social v non-social
                % 3rd ind in 3D mat statsType = {'pVec', 'omegaVec', 'meanNullVec', 'meanErrVec' 'nullOmegaVec', 'maxNullOmegaVec'};
                [allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('pVec',statsType)), pStatsTable, ~] = anovan(trialSpikes,{trialLabels},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
                top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
                bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
                if isnan(top/bottom)
                  allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('omegaVec',statsType)) = 0;
                else
                  allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('omegaVec',statsType)) = top/bottom;
                end
                % Perform Calculations on scrambles
                [nullPVec, nullOmegaVecSingle] = deal(zeros(1,scrambleCount));
                for rand_ind = 1:scrambleCount
                  [nullPVec(rand_ind), pStatsTable, ~] = anovan(trialSpikes,{trialLabels(randperm(length(trialLabels)))},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
                  top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
                  bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
                  nullOmegaVecSingle(rand_ind) = top/bottom;
                end
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('meanNullVec',statsType)) = mean(nullPVec);
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('meanErrVec',statsType)) = std(nullPVec)/sqrt(length(nullPVec));
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('nullOmegaVec',statsType)) = mean(nullOmegaVecSingle);
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('maxNullOmegaVec',statsType)) = max(nullOmegaVecSingle);
              end
            end
          end
        end
      else
        disp('Skipping')
      end
    end
    
  end
  save(fullfile(params.outputDir, 'allStatsArray'), 'allStatsArray');
  fprintf('Done in %d hours \n', toc/3600)
else
  fprintf('Loading statsArray from saved data... \n')
  load(fullfile(params.outputDir, 'allStatsArray.mat'), 'allStatsArray');
  assert(length(allStatsArray) == length(runList), 'allStatsArray length does not match runList length');
end

%{'pVec', 'omegaVec', 'meanNullVec', 'meanErrVec' 'nullOmegaVec', 'maxNullOmegaVec'}

runStruct = spikeDataBank.(runList{1});
starts = (runStruct.start:binStep:(runStruct.end - binSize))';
xlabelPlot = starts(1:8:length(starts));
stimOnInd = find(starts == 0);
stimEndInd = find(starts == 2800);

if params.plotANOVA
  for run_i = 1:length(allStatsArray)
    statsArray = allStatsArray{run_i};
    % Plot the results for each unit seen
    for chan_ind = 1:length(statsArray)
      for unit_ind = 1:length(statsArray{chan_ind})
        if unit_ind == 1
          ANOVAvarName = ['Ch' num2str(chan_ind) ' Unsorted - SocVsNonSoc'];
        elseif unit_ind == length(statsArray{chan_ind})
          ANOVAvarName = ['Ch' num2str(chan_ind) ' MUA - SocVsNonSoc'];
        else
          ANOVAvarName = ['Ch' num2str(chan_ind) ' U' num2str(unit_ind-1) ' - SocVsNonSoc'];
        end
        if ~any(any(isnan(statsArray{chan_ind}{unit_ind}(:,:,1))))
          
          pVec = statsArray{chan_ind}{unit_ind}(:,:,strcmp('pVec',statsType));
          omegaVec = statsArray{chan_ind}{unit_ind}(:,:,strcmp('omegaVec',statsType));
          nullVec = statsArray{chan_ind}{unit_ind}(:,:,strcmp('meanNullVec',statsType));
          nullOmegaVec = statsArray{chan_ind}{unit_ind}(:,:,strcmp('nullOmegaVec',statsType));
          
          % Plot the p values
          titleString = sprintf('%s - Sliding Scale ANOVA - %s', runList{run_i} ,ANOVAvarName);
          k = figure('NumberTitle', 'off', 'Name', titleString,'units','normalized','outerposition',[0 0 1 1]);
          title(titleString)
          
          hold on
          plot(pVec,'linewidth',2)
          plot(nullVec,'linewidth',3)
          plot([0,size(pVec,1)],[0.05, 0.05],'k','linewidth',3)          % Plot a line @ .05
          xlim([0,size(pVec,1)]);
          % Calculate how many values are significant within each line. Create Legend
          fracSig = round(sum(pVec < 0.05)/length(pVec), 3, 'significant');
          legendText = cell(length(target),1);
          for leg_ind = 1:length(target)
            legendText{leg_ind} = sprintf('%s (%s sig)', target{leg_ind}, num2str(fracSig(leg_ind)));
          end
          legend(legendText, 'AutoUpdate','off');
          
          plot([stimOnInd, stimOnInd], ylim(),'k','linewidth',4);
          plot([stimEndInd, stimEndInd], ylim(),'k','linewidth',4);
          xticks(1:8:length(starts))
          xticklabels(xlabelPlot);
          ylim([0,1]);
          

          % Save and close
          %savefig(k, fullfile(spikeDataBank.(runList{run_i}).figDir,titleString))
          %close(k)
          
          % plot the Omega values
          titleString = sprintf('%s - Sliding Scale Omega Squared - %s', runList{run_i} ,ANOVAvarName);
          h = figure('NumberTitle', 'off', 'Name', titleString,'units','normalized','outerposition',[0 0 1 1]);
          title(titleString)
          hold on
          plot(omegaVec,'linewidth',2)
          plot(nullOmegaVec,'linewidth',3)
          legend(target, 'AutoUpdate','off');
          xlim([0,size(omegaVec,1)]);
          xticks(1:8:length(starts))
          xticklabels(xlabelPlot);
          ylim([0,0.2]);
          plot([stimOnInd, stimOnInd], ylim(),'k','linewidth',4);
          plot([stimEndInd, stimEndInd], ylim(),'k','linewidth',4);
          % Save and close
          %savefig(h, fullfile(spikeDataBank.(runList{run_i}).figDir,titleString))
          %close(h)
          
        end
      end
    end
  end
end

fprintf('ANOVA Omega Calculations finished... \n')

% Step 3 - Count Results of ANOVA across all units and count stretches of significant
% bins.
totalUnitCount = 0;
totalChannelCount = 0;
groupingType = {'Unsorted', 'Unit', 'MUA'};
% target = {'socialInteraction','agents','interaction'};, pulled from params.
dataType = {'sigBins','nullSigBins'};
statType = {'Counts', 'Sig Run Lengths',' Mean Stretch Lengths', 'Max run lengths'};
omegaStatType = {'Bin Value', 'Maximum values'};

ANOVAmat = zeros(length(epochRates{1}), length(target), length(groupingType), length(dataType)); % (binCount, target, group, dataType)
targetRunLens = cell(length(target), length(groupingType), length(statType));
omegaData = cell(length(target), length(groupingType), length(omegaStatType));

for run_ind = 1:length(allStatsArray)
  for chan_ind = 1:length(allStatsArray{run_ind})
    unitCount = length(allStatsArray{run_ind}{chan_ind});
    totalUnitCount = totalUnitCount + (unitCount - 2);
    totalChannelCount = totalChannelCount + 1;
    for unit_ind = 1:unitCount
      uPVec = allStatsArray{run_ind}{chan_ind}{unit_ind}(:,:,strcmp('pVec',statsType));
      if ~isempty(uPVec)
        uPVec(uPVec == 0) = nan;
        uNullVec = allStatsArray{run_ind}{chan_ind}{unit_ind}(:,:,strcmp('meanNullVec',statsType));
        uNullVec(uNullVec == 0) = nan; % Temporary, shouldn't be needed once init above uses nan.
        omegaVec = allStatsArray{run_ind}{chan_ind}{unit_ind}(:,:,strcmp('omegaVec',statsType));
        %omegaVec(isnan(omegaVec)) = 0;
        % Check for significant bins
        tmpSigCount = double(uPVec < 0.05);
        tmpNullSigCount = double(uNullVec < 0.05);
        tmpSigCount(isnan(uPVec)) = nan;
        tmpNullSigCount(isnan(uNullVec)) = nan;
        % Add to relevant structures
        if unit_ind == 1
          group_i = 1;
        elseif unit_ind == unitCount
          group_i = 3;
        else
          group_i = 2;
        end
        % Save significant bins and null bins correctly.
        ANOVAmat(:, :, group_i, 1) = ANOVAmat(:, :, group_i, 1) + tmpSigCount;
        ANOVAmat(:, :, group_i, 2) = ANOVAmat(:, :, group_i, 2) + tmpNullSigCount;
        % Keep count of consecutive bins
        for targ_i = 1:length(target)
          trace = tmpSigCount(:,targ_i);
          trace(isnan(trace)) = 0;
          starts = find(diff([0; trace]) == 1);
          ends = find(diff([trace; 0]) == -1)+1;
          runLengths = ends - starts;
          targetRunLens{targ_i, group_i, 1} = [targetRunLens{targ_i, group_i, 1}; sum(trace)];
          targetRunLens{targ_i, group_i, 2} = [targetRunLens{targ_i, group_i, 2}; runLengths];
          targetRunLens{targ_i, group_i, 3} = [targetRunLens{targ_i, group_i, 3}; mean(runLengths)];
          targetRunLens{targ_i, group_i, 4} = [targetRunLens{targ_i, group_i, 4}; max(runLengths)];
          
          omegaTrace = omegaVec(:,targ_i)';
          omegaData{targ_i, group_i, 1} = [omegaData{targ_i, group_i, 1}; omegaTrace];
          omegaData{targ_i, group_i, 2} = [omegaData{targ_i, group_i, 2}; max(omegaTrace)];
          
        end
      end
    end
  end
end

% Plot Results - using values found in ANOVAmat and targetRunLens
% Fig 1 - 'Social Interactions, Run Length Stats' 4 * 3 grid, 1 subplot per
% group and stat.
statTypePlotLabel = {'Number of Significant Bins','Length of Significant runs', 'Average Significant Run Length','Max Significant Run Length'};
xLabelPlotArray = {'Counts', 'Run Lengths', 'Run Lengths', 'Run Lengths'};

for targ_i = 1:length(target)
  figTitle = sprintf('Summary Statistic for ANOVA curves - %s', target{targ_i});
  h = figure('NumberTitle', 'off', 'Name', figTitle,'units','normalized','outerposition',[0 0 1 1]);
  sgtitle(figTitle);
  for group_i = 1:length(groupingType)
    for plot_i = 1:length(statType)
      plotInd = ((group_i - 1) * length(statType)) + plot_i;
      subplot(length(groupingType), length(statType), plotInd);
      plotData = targetRunLens{targ_i, group_i, plot_i};
      histogram(plotData);
      if plot_i == 1
        ylabel(groupingType{group_i})
      end
      xlabel(xLabelPlotArray{plot_i})
      plotTitle = sprintf('%s (90th p = %s)', statTypePlotLabel{plot_i}, num2str(round(prctile(plotData, 90), 2)));
      title(plotTitle);
    end
  end
end

omegaStatTypePlotLabel = {'Omega Squared Values','Maximum Omega Squared Values'};
% Figure 2 - the mean Omega Curve.
for targ_i = 1:length(target)
  figTitle = sprintf('Summary Statistic for Omega curves - %s', target{targ_i});
  h = figure('NumberTitle', 'off', 'Name', figTitle,'units','normalized','outerposition',[0 0 1 1]);
  sgtitle(figTitle);
  for group_i = 1:length(groupingType)
    for plot_i = 1:length(omegaStatType)
      plotInd = ((group_i - 1) * length(omegaStatType)) + plot_i;
      subplot(length(groupingType), length(omegaStatType), plotInd);
      plotData = omegaData{targ_i, group_i, plot_i};
      plotData = [plotData(:)];
      histogram(plotData);
      if plot_i == 1
        ylabel(groupingType{group_i})
      end
      xlabel(omegaStatType{plot_i});
      plotTitle = sprintf('%s (90th p = %s)', omegaStatTypePlotLabel{plot_i}, num2str(round(prctile(plotData, 90), 2)));
      title(plotTitle);
    end
  end
end

% Given the Outcome of above figures, I think revamping those below isn't
% worth the effort, and other analyses will be more fruitful. 
% legendCells = cell(length(target)*2,1);
% for legend_i = 1:length(target)
%   legendCells{legend_i} = target{legend_i};
%   legendCells{legend_i+length(target)} = ['Label scramble ' target{legend_i}];
% end
% 
% figure
% subplot(3,1,1)
% plot(allUnitTraces,'Linewidth',3);
% legend(legendCells);
% ylim([0 totalUnitCount/5]);
% xlim([0 length(allUnitTraces)])
% title('Significant Units per Bin')
% subplot(3,1,2)
% plot(allMUATraces,'Linewidth',3);
% legend(legendCells);
% ylim([0 totalUnitCount/5]);
% xlim([0 length(allUnitTraces)])
% title('Significant MUA per Bin')
% subplot(3,1,3)
% plot(allUnsortedTraces,'Linewidth',3);
% legend(legendCells);
% ylim([0 totalUnitCount/5]);
% xlim([0 length(allUnitTraces)])
% title('Significant Unsorted per Bin')
% 
% % Fig 2 - Numbers of bins per stimuli, length of stretches
% figure()
% for ii = 1:length(target)
%   %Plot significant bin count per unit
%   subplot(length(target), 2, (ii*2)-1)
%   histogram(sigBinCountTotal(:,ii),50)
%   title(sprintf('Number of bins per unit (%s)',target{ii}))
%   %Plot stretch duration per unit
%   subplot(length(target), 2, (ii * 2))
%   histogram(targetRunLengths.(target{ii}))
%   title(sprintf('Length of significant bin runs per unit (%s)',target{ii}))
% end
% 
% % Fig 3 - Plot Omega curves, save to Run folder.
% allMaxOmegas = [];
% figData.binSize = binSize; %figData required to save figure.
% figData.binStep = binStep;
% for run_ind = 1:length(runList)
%   omegaVec = spikeDataBank.(runList{run_ind}).omegaVec;
%   for chan_ind = 1:length(omegaVec)
%     for unit_ind = 1:length(omegaVec{chan_ind})
%       if unit_ind == 1
%         ANOVAvarName = ['Ch' num2str(chan_ind) ' Unsorted'];
%       elseif unit_ind == length(omegaVec{chan_ind})
%         ANOVAvarName = ['Ch' num2str(chan_ind) ' MUA'];
%       else
%         ANOVAvarName = ['Ch' num2str(chan_ind) ' unit ' num2str(unit_ind-1)];
%         allMaxOmegas = [allMaxOmegas; spikeDataBank.(runList{run_ind}).maxOmegaVec{chan_ind}{unit_ind}];
%       end
%       figure()
%       plot(omegaVec{chan_ind}{unit_ind},'linewidth',2)
%       hold on
%       xlim([0,size(omegaVec{chan_ind}{unit_ind},1)]);
%       ylim([0,0.2]);
%       title(sprintf('Sliding Window ANOVA Omega - %s, %d ms bin', ANOVAvarName, binSize))
%       legendText = cell(length(target),1);
%       for leg_ind = 1:length(target)
%         legendText{leg_ind} = sprintf('%s', target{leg_ind});
%       end
%       legend(legendText);
%       starts = spikeDataBank.(runList{run_ind}).epochs(:,1);
%       xticks(1:10:length(starts))
%       xticklabels(starts(1:10:length(starts)));
%       fileName = sprintf('Omega Curve - %s, %d ms bins, %d ms step', ANOVAvarName, binSize, binStep);
%       savePath = [spikeDataBank.(runList{run_ind}).figDir filesep];
%       saveFigure(savePath, fileName, figData, 1, 0, 0, runList{run_ind}, 'close')
%     end
%   end
% end
% 
% %Distribution of peak sensitivities 
% for ii = 1:size(allMaxOmegas,2)
%   figure
%   hist(allMaxOmegas(:,ii),20);
%   title(target{ii});
% end

end

function [spikeDataBank, frameFiringStruct]  = frameFiringRates(spikeDataBank,params)
% Generates means and distributions based on what is being looking at.
disp('Starting Frame Firing Rate Analysis...');

% Generate variables needed
runList = fields(spikeDataBank);

if ~exist(params.outputDir, 'dir')
  mkdir(params.outputDir)
end

% Step 1 - generate bin times and spike rates.
if ~isfield(spikeDataBank.(runList{end}), 'frameFiringRates')
  for run_ind = 1:length(runList)
    runStruct = spikeDataBank.(runList{run_ind});
    if length(unique(cellfun('length',runStruct.attendedObjData.frameStartInd))) == 1 % If all the videos are the same number of frames
      starts = runStruct.attendedObjData.frameStartInd{1}'+params.delay;
      ends = runStruct.attendedObjData.frameEndInd{1}'+params.delay;
      spikeDataBank.(runList{run_ind}).frameTimes = [starts,ends];
      spikeDataBank.(runList{run_ind}).frameFiringRates = cell(length(starts),1);
      frameFiringRatesTmp = cell(length(starts),1);
      for frame_ind = 1:length(starts)
        % spikeDataBank.run.framingFiringRates{epoch/bin}{channel}{unit}{stim}
        [frameFiringRatesTmp{frame_ind}, ~, ~] = spikeCounter(spikeDataBank.(runList{run_ind}).spikesByEvent, starts(frame_ind), ends(frame_ind));
      end
    else
      error('Different stimuli contain different number of frames. Implement different spikeCounting method.')
    end
    % Step 1.5 - Rearrange frameFiringRatesTmp to match attendedObjVect data {channel}{unit}{stimuli}(trials*frames)
    frameCount = length(frameFiringRatesTmp);
    trialCount = length(frameFiringRatesTmp{1}{1}{1}{1}.counts);
    frameFiringRates = initNestedCellArray(frameFiringRatesTmp{1},'zeros',[trialCount, frameCount]);
    for chan_ind = 1:length(frameFiringRatesTmp{1})
      for unit_ind = 1:length(frameFiringRatesTmp{1}{chan_ind})
        frameFiringRatesUnitTmp = initNestedCellArray(runStruct.attendedObjData.attendedObjVect, 'zeros', [size(runStruct.attendedObjData.attendedObjVect{1})],1);
        for frame_ind = 1:length(frameFiringRatesTmp)
          for stim_ind = 1:length(frameFiringRatesTmp{frame_ind}{chan_ind}{unit_ind})
            if frame_ind == 1
              frameFiringRatesUnitTmp{stim_ind} = zeros(size(runStruct.attendedObjData.attendedObjVect{stim_ind}));
            end
            if params.useRates
            frameFiringRatesUnitTmp{stim_ind}(:,frame_ind) = frameFiringRatesTmp{frame_ind}{chan_ind}{unit_ind}{stim_ind}.rates;
            else
              frameFiringRatesUnitTmp{stim_ind}(:,frame_ind) = frameFiringRatesTmp{frame_ind}{chan_ind}{unit_ind}{stim_ind}.counts;
            end
          end
        end
        frameFiringRates{chan_ind}{unit_ind} = frameFiringRatesUnitTmp;
      end
    end
    spikeDataBank.(runList{run_ind}).frameFiringRates = frameFiringRates;
    disp(run_ind)
  end
  saveSpikeDataBank(spikeDataBank, 2, 'save',fileparts(params.outputDir));
else
  fprintf('Frame firing rates already calculated., continuing... \n');
end

% Step 2 - Go through each run, sum frame counts/rates associated with the
% specific objects being attended.
objList = spikeDataBank.(runList{1}).attendedObjData.objList;
objListBroad = {'Face','Body','Hand','GazeFollow','Object','Bkg'};

if params.broadLabels
  objListPlot = objListBroad;
else
  objListPlot = objList;
end

% Step 3 - Generate vectors with data from all runs, organized as follows
% from ObjFrameFiringRates{channel}{unit}{stim}{obj}{dataType} to
% objFrameFiringRatesTotal{stim}{obj}{groupingType}{dataType}
groupingType = {'Unsorted','Units','MUA'};
dataType = {'Raw','Mean','Run Ind'};

% Pooling across runs requires vector of all stim, extract the eventIDs field, generate a cell array of unique stimuli
allStimuliVec = struct2cell(structfun(@(x) x.eventIDs, spikeDataBank,'UniformOutput', 0));
[allStimuliVec, ~, ic] = unique(vertcat(allStimuliVec{:}));
allStimuliVecCounts = accumarray(ic,1);

objFrameFiringRatesTotal = cell([length(allStimuliVec),length(groupingType), length(objListPlot), length(dataType)]);
%objFrameFiringRatesTotal{stim_ind, group_ind, obj_ind, data_ind};

channelUnitMat = [];
for run_ind = 1:length(runList)
  frameFiringRates = spikeDataBank.(runList{run_ind}).frameFiringRates;
  attendedObjVect = spikeDataBank.(runList{run_ind}).attendedObjData.attendedObjVect;
  eventIDs = spikeDataBank.(runList{run_ind}).eventIDs;
  chanCount = 0;
  unitCount = 0;
  
  % Per Stimuli Plot
  for channel_ind = 1:length(frameFiringRates)
    chanCount = chanCount + 1;
    for unit_ind = 1:length(frameFiringRates{channel_ind})
      unitCount = unitCount + 1;
      if unit_ind == 1
        groupInd = 1;  %Unsorted
      elseif unit_ind == length(frameFiringRates{channel_ind}) % MUA
        groupInd = 3;  %MUA
      else
        groupInd = 2;  %Unit
      end
      for stim_ind = 1:length(attendedObjVect)
        stimStoreInd = strcmp(spikeDataBank.(runList{run_ind}).eventIDs{stim_ind}, allStimuliVec);
        stimAttendedObj = attendedObjVect{stim_ind};
        spikeStruct = frameFiringRates{channel_ind}{unit_ind}{stim_ind};
        %ObjFrameFiringRatesStim = initNestedCellArray([length(objListPlot), length(dataType)],'zeros');
        for obj_ind = 1:length(objList)
          objRates = spikeStruct(strcmp(stimAttendedObj, objList{obj_ind}));
          
          % Identify correct object group, when using broad labels.
          if params.broadLabels
            switch find(strcmp(objList,objList{obj_ind}))
              case {1,7};         objStoreInd = 1;
              case {2,8};         objStoreInd = 2;
              case {3,4,9,10};    objStoreInd = 3;
              case {5,11};        objStoreInd = 4;
              case {6,12};        objStoreInd = 5;
              case 13;            objStoreInd = 6;
            end
          else
            objStoreInd = obj_ind;
          end
          if ~isempty(objRates)
            %ObjFrameFiringRatesStim{objStoreInd}{1} = [ObjFrameFiringRatesStim{objStoreInd}{1}; objRates];
            objFrameFiringRatesTotal{stimStoreInd, groupInd, objStoreInd, 1} = [objFrameFiringRatesTotal{stimStoreInd, groupInd, objStoreInd, 1}; objRates];
            objFrameFiringRatesTotal{stimStoreInd, groupInd, objStoreInd, 2} = [objFrameFiringRatesTotal{stimStoreInd, groupInd, objStoreInd, 2}; mean(objRates)];
            objFrameFiringRatesTotal{stimStoreInd, groupInd, objStoreInd, 3} = [objFrameFiringRatesTotal{stimStoreInd, groupInd, objStoreInd, 3}; run_ind];
          end
        end
      end
    end
  end
  % Structure is ObjFrameFiringRates{stim}{obj}{channel}{unit}{dataType}
  channelUnitMat = [channelUnitMat; [run_ind, chanCount, unitCount]];
end
disp('Finished calculating objFrameFiringRatesTotal...')

% Generate the correct labels depending on whether broad labels are used
% for objects.
% Broad Label - Swaps labels of individual stimuli for broader catagories,
% as defined in stimParamFile and the parameters.
tmp = load(params.stimParamsFilename);
for event_i = 1:length(tmp.paramArray)
  totalEventIDs{event_i} = tmp.paramArray{event_i}{1}; %per the stimParamFile spec, this is the event ID
end
totalEventIDs = totalEventIDs';
[~, paramSortVec] = ismember(allStimuliVec, totalEventIDs);
paramArray = tmp.paramArray(paramSortVec);

%Iterate across stimuli and assign new labels.
allStimuliVecBroad = cell(length(allStimuliVec),1);
for label_ind = 1:length(allStimuliVec)
  paramStimSet = paramArray{label_ind};
  allStimuliVecBroad{label_ind} = paramStimSet{ismember(paramStimSet,params.broadLabelPool)};
end
[uniqueStimLabels, ~, stimIndex] = unique(allStimuliVecBroad);

% Find out how many of each of the newly labeled stimuli there are
% uniqueStimLabelCounts = cell2mat(arrayfun(@(x)length(find(stimIndex == x)), unique(stimIndex), 'Uniform', false));

% Step 5 - Generate figures
% Produces 72 images
for stim_ind = 1:length(uniqueStimLabels)
  for group_ind = 1:length(groupingType)
    figTitle = sprintf('%s, Per Object Rates, %s - %s', uniqueStimLabels{stim_ind}, dataType{2}, groupingType{group_ind});
    figFilePath = fullfile(params.outputDir, figTitle);
    if ~exist([figFilePath, '.fig'],'file')
      % Fig 1 - 'Chasing, Per Object Rates Means - MUA'
      stimMatInd = strcmp(uniqueStimLabels(stim_ind), allStimuliVecBroad);
      stimObjData = objFrameFiringRatesTotal(stimMatInd, group_ind, :,  2);
      plotArray = cell(length(objListPlot),2);
      removeInd = false(size(stimObjData,3),1);
      for obj_ind = 1:size(stimObjData,3)
        plotArray{obj_ind,1} = vertcat(stimObjData{:,:,obj_ind});
        removeInd(obj_ind) = isempty(plotArray{obj_ind,1});
        plotArray{obj_ind,2} = objListPlot{obj_ind};
      end
      plotArray(removeInd,:) = [];
      h = figure('Name', figTitle, 'NumberTitle', 'off');
      sgtitle(figTitle)
      hold on
      uniqueObjLabels = plotArray(:,2);
      [tmpValues, tmpLabels] = deal([]);
      for obj_ind = 1:length(uniqueObjLabels)
        subplot(2,length(uniqueObjLabels),obj_ind+length(uniqueObjLabels))
        singleObjMeans = plotArray{obj_ind,1};
        histogram(singleObjMeans, 20)
        title(sprintf('%s (\x03bc  = %s)',uniqueObjLabels{obj_ind}, num2str(round(mean(singleObjMeans), 2)) ));
        tmpValues = [tmpValues; singleObjMeans];
        tmpLabels = [tmpLabels; repmat(uniqueObjLabels(obj_ind) ,[length(singleObjMeans),1])];
      end
      subplot(2,length(uniqueObjLabels),[1:length(uniqueObjLabels)])
      boxplot(tmpValues, tmpLabels, 'Symbol', 'o')
      linkaxes(h.Children(2:length(h.Children)-1),'xy')
      savefig(fullfile(params.outputDir, figTitle))
      close(h)
    end 
  end
end

% Produces 36 Images
for obj_ind = 1:length(objListPlot)
  for group_ind = 1:length(groupingType)
    % Fig 2 - 'Mean Face Rates - MUA, All Stimuli'
    figTitle = sprintf('%s %s rates, %s, All Stimuli', dataType{2}, objListPlot{obj_ind}, groupingType{group_ind});
    figFilePath = fullfile(params.outputDir, figTitle);    
    if ~exist([figFilePath, '.fig'],'file')
      % Collect relevant data for plot
      stimObjData = objFrameFiringRatesTotal(:, group_ind, obj_ind,  2);
      plotArray = cell(length(uniqueStimLabels),2);
      removeInd = false(length(uniqueStimLabels),1);
      for stim_i = 1:length(uniqueStimLabels)
        stimMatInd = strcmp(uniqueStimLabels(stim_i), allStimuliVecBroad);
        plotArray{stim_i,1} = vertcat(stimObjData{stimMatInd});
        removeInd(stim_i) = isempty(plotArray{stim_i,1});
        plotArray{stim_i,2} = uniqueStimLabels{stim_i};
      end
      plotArray(removeInd,:) = [];
      
      if ~isempty(plotArray)
        % Set up grid of subplots correctly
        h = figure('Name', figTitle, 'NumberTitle', 'off', 'units','normalized','outerposition',[0 0 1 1]);
        sgtitle(figTitle)
        hold on
        stim2Plot = size(plotArray,1);
        [tmpValues, tmpLabels] = deal([]);
        for stim_ind = 1:stim2Plot
          subplot(2,stim2Plot,stim_ind+stim2Plot)
          stimObjMeans = plotArray{stim_ind,1};
          histogram(stimObjMeans, 20);
          title(sprintf('%s (\x03bc  = %s)',plotArray{stim_ind,2},num2str(round(mean(stimObjMeans), 2))));
          tmpValues = [tmpValues; stimObjMeans];
          tmpLabels = [tmpLabels; repmat(plotArray(stim_ind,2) ,[length(stimObjMeans),1])];
        end
        subplot(2,stim2Plot,1:stim2Plot)
        boxplot(tmpValues, tmpLabels, 'Symbol', 'o')
        linkaxes(h.Children(2:length(h.Children)-1),'xy')
        savefig(fullfile(params.outputDir, figTitle))
        close(h)
      end
    end
  end
end

% Convert to Arrays of run indices into tables
frameFiringStruct.channelUnitMat = channelUnitMat;
frameFiringStruct.objList = objListPlot;
frameFiringStruct.groupList = groupingType;
frameFiringStruct.stimList = uniqueStimLabels;
frameFiringStruct.dataList = dataType(dataInd2Plot);

end

function  [spikeDataBank, stimPSTH] = noveltyAnalysis(spikeDataBank, stimPSTH, meanPSTHStruct, frameFiringStruct, params)
% Function seeks to analyze whether most active PSTHes are enriched from
% novel runs.
% Inputs:
% - spikeDataBank
% - stimPSTH - the output of meanPSTH, which has indexing information in
% meanPSTHStruct.IndStructs.
disp('Starting Novelty Analysis...');

if ~exist(params.outputDir, 'dir')
  mkdir(params.outputDir)
end

stimuliFileNames = meanPSTHStruct.IndStructs{1};
groupTypes = meanPSTHStruct.IndStructs{2};
dataTypes = meanPSTHStruct.IndStructs{3};
stimuliNames = cellfun(@(x) extractBetween(x, 1, length(x)-4), stimuliFileNames);
stimPresMat = meanPSTHStruct.stimPresMat;
epochs = {[300 800], [860 3380], [3680 4100]};
epochNames = {'Fixation','Stim Presentation','Reward'};
dataMetric = {'Max','Avg'};
lineColors = {'k','b'};
figLegend = {'Metric Trace', 'Recording pause > 7d','Presentation Pause > 7d'};
stimPSTHSortMat = cell(size(stimPresMat,1), size(stimPresMat,2), length(epochNames));

for stim_i = 1:length(stimuliNames)
  stimData = stimPSTH(stim_i,:,:);
  for group_i = 1:length(groupTypes)
    psthData = stimData{:,group_i,strcmp(dataTypes, 'PSTH')};
    presCountData = stimData{:,group_i,strcmp(dataTypes, 'presCount')};
    recData = stimData{:,group_i,strcmp(dataTypes, 'daysSinceLastRec')};
    daysPresData = stimData{:,group_i,strcmp(dataTypes, 'daysSinceLastPres')};
    
    % vertical lines denoting long time since last Rec
    recLine = find(recData > 30);
    presLine = find(daysPresData(2:end) > 30);
    if ~isempty(recLine) && ~isempty(presLine)
      recLine = recLine(logical([1;diff(recLine)>1]));
      tmp1 = ones(length(recLine),1);
      tmp2 = ones(length(presLine),1) * 2;
      lineMat = [[recLine;presLine],[tmp1;tmp2]];
      legendInd = [1, length(tmp1)+1, length(lineMat)+1];
    else
      lineMat = [];
      legendInd = [];
    end
    
    
    metaPlotTitle = sprintf('%s - PSTH Values - %s', stimuliNames{stim_i},  groupTypes{group_i});
    h = figure('Name', metaPlotTitle, 'NumberTitle', 'off', 'units','normalized','outerposition',[0 0 1 1]);
    sgtitle(metaPlotTitle);
      
    for epoch_i = 1:length(epochs)
      % Prepare data types of Interest
      epoch = epochs{epoch_i};
      psthMax = max(psthData(:,epoch(1):epoch(2)),[],2);
      psthMean = mean(psthData(:,epoch(1):epoch(2)),2);
      dataMat = [psthMax, psthMean];
      
      % Save sorted matricies
      [~, maxSort] = sort(psthMax);
      [~, meanSort] = sort(psthMean);
      stimPSTHSortMat{stim_i, group_i, epoch_i} = [meanSort, maxSort];

      for data_i = 1:length(dataMetric)
        subPlotTitle = sprintf('%s - %s', dataMetric{data_i}, epochNames{epoch_i});
        plotInd = epoch_i + ((data_i-1) * 3);
        subplot(length(dataMetric), length(epochs), plotInd)
        
        lineArray = gobjects(size(lineMat,1)+1,1);
        lineArray(1) = plot(1:length(presCountData), dataMat(:,data_i));
        title(subPlotTitle);
        xlim([1, length(presCountData)])
        xlabel('Presentation Count')
        ylabel('Rates');
        tickLabels = xticklabels();
        newLabel = cell(length(tickLabels),1);
        for tick_i = 1:length(tickLabels)
          tickVal = round(str2num(tickLabels{tick_i}));
          newLabel{tick_i} = presCountData(tickVal);
        end
        xticklabels(newLabel);
        hold on
        if ~isempty(recLine) && ~isempty(presLine)
          for line_i = 1:size(lineMat,1)
            lineArray(line_i+1) = plot([lineMat(line_i,1), lineMat(line_i,1)], ylim(), 'Color', lineColors{lineMat(line_i,2)}, 'lineWidth',3);
          end
        end
        legend(lineArray(legendInd), figLegend,'AutoUpdate','off')
      end
    end
    savefig(h, fullfile(params.outputDir, metaPlotTitle));
    close(h);
  end
  
end

% Figure 1 - iterate through stimuli, grabbing mean and max values across
% presentations in order, plot them on a single line. Mark dates where long
% recording dates were taken with vertical lines.


end