function [analysisOutFilename] = runBatchAnalysis(inputs)
%%Unpack Inputs
analysisLog = struct();
load(inputs{1})   % Non spike variables, including path to spikes.
spikeDataBank = saveSpikeDataBank([], [], 'load', outputDir); %Spike variables

%Overwrite switches with what is currently in file
load(fullfile(outputDir, 'batchAnalysisParams.mat'));

%% Analyses
runList = fields(spikeDataBank);

if ~isfield(spikeDataBank.(runList{end}), 'stimPresCount')
  spikeDataBank = stimulusStatistics(spikeDataBank);
  %Save modified struct.
  saveSpikeDataBank(spikeDataBank, 2, 'save',outputDir);
end

if plotSwitch.stimPresCount
  disp('plot stimPresCount')
  %Plot as an image the 'daysSinceLastPres' matrix, stimuli on Y, date on
  %X.will likely require a figure callback for making Y axis labels
  %legible.
  %At the top of the plot, I will have a single vector with 'days since
  %last recording' to highlight days after long breaks.
end

if ~exist('unitCounts','var')
  [trueCellInd, trueCellRun, unitCounts] = trueCellCount(cellCountParams.batchRunxls, cellCountParams.recordingLogxls);
end

% Remove repeated Runs
if ~calcSwitch.excludeRepeats && isfield(analysisLog, 'repeatsExcluded')
  error('Repeats already excluded in this spikeDataBank, delete and restart or change parameters')
elseif calcSwitch.excludeRepeats && ~isfield(analysisLog, 'repeatsExcluded')
  % Exclude repeated recordings at the same site.
  for run_ind = 1:length(runList)
    sessionName = extractBetween(runList{run_ind}, 2, length(runList{run_ind}));
    validInd = trueCellInd(strcmp(sessionName,trueCellRun));
    if sum(validInd) == 0
      % Remove entire field if all channels are repeated recordings.
      spikeDataBank = rmfield(spikeDataBank,(runList{run_ind}));
    else
      for event_ind = 1:length(spikeDataBank.(runList{run_ind}).spikesByEvent)
        % Remove individual channel info where one of the channels is
        % recording new units.
        spikeDataBank.(runList{run_ind}).spikesByEvent{event_ind} = spikeDataBank.(runList{run_ind}).spikesByEvent{event_ind}(validInd);
      end
    end
  end
  %Save modified struct.
  analysisLog.repeatsExcluded = 1;
  saveSpikeDataBank(spikeDataBank, 2, 'save',outputDir);
  clearvars spikeDataBank %Delete this to prevent saving with other variables.
  save(fullfile(outputDir, [preprocessParams.spikeDataFileName 'Vars']));
  spikeDataBank = saveSpikeDataBank([], [], 'load', outputDir); % Load spikeDataBank back.
end

%% Combine PSTH across all runs for a particular stimulus.
%This will crash if the PSTHs aren't the same length.
if plotSwitch.meanPSTH && ~exist('meanPSTHStruct','var')
  [spikeDataBank, meanPSTHStruct] = meanPSTH(spikeDataBank, meanPSTHParams);
  saveSpikeDataBank(spikeDataBank, 2, 'save',outputDir);
  clearvars spikeDataBank %Delete this to prevent saving with other variables.
  save(fullfile(outputDir, [preprocessParams.spikeDataFileName 'Vars']));
  spikeDataBank = saveSpikeDataBank([], [], 'load', outputDir); % Load spikeDataBank back.
end

%% Gather information on frame rates
if plotSwitch.frameFiringRates && ~exist('frameFiringStruct','var')
  [spikeDataBank, frameFiringStruct] = frameFiringRates(spikeDataBank, frameFiringParams);
  saveSpikeDataBank(spikeDataBank, 2, 'save',outputDir);
  clearvars spikeDataBank %Delete this to prevent saving with other variables.
  save(fullfile(outputDir, [preprocessParams.spikeDataFileName 'Vars']));
  spikeDataBank = saveSpikeDataBank([], [], 'load', outputDir); % Load spikeDataBank back.
end

%% Check whether the novelty of the runs
if plotSwitch.novelty
  assert(logical(exist('meanPSTHStruct','var')), 'Must run w/ meanPSTH enabled for novelty analysis');
  spikeDataBank = noveltyAnalysis(spikeDataBank, meanPSTHStruct,frameFiringStruct);
end

%% Perform sliding window ANOVA and Omega calculations
if plotSwitch.slidingWindowANOVA % && ~isfield(spikeDataBank, [Some new field generated by function])
  spikeDataBank = slidingWindowANOVA(spikeDataBank, slidingANOVAParams);
end

end

%% Functions

function spikeDataBank = stimulusStatistics(spikeDataBank)
% Stimuli Presentation count and 'Novelty' Related Information.
%Code below creates a single large vector of stimuli used, and uses this to
%create individual vectors containing which viewing of the stimulus this
%represent (i.e. 'this run represents the 10th viewing of X.avi'). It also
%appends a dateTime vector to each structure related to how long since the
%last recording day.

runList = fields(spikeDataBank);

%extract the eventIDs field, generate a cell array of unique stimuli
allStimuliVec = struct2cell(structfun(@(x) x.eventIDs, spikeDataBank,'UniformOutput', 0));
allStimuliVec = unique(vertcat(allStimuliVec{:}));

%Produce matrix (N stim * M runs) which gives 0 for non present stim, count of stim presentation otherwise.
stimLogicalArray = zeros(length(allStimuliVec),length(runList));
for run_ind = 1:length(runList)
  stimLogicalArray(:,run_ind) = ismember(allStimuliVec,spikeDataBank.(runList{run_ind}).eventIDs);
end
csStimLogicalArray = cumsum(stimLogicalArray,2);
csStimLogicalArray(~stimLogicalArray) = 0;

% When was a stimulus first seen? Index of runList where first presentation took place.
firstStimPresInd = zeros(length(allStimuliVec),1);
for stim_ind = 1:length(allStimuliVec)
  firstStimPresInd(stim_ind) = find(stimLogicalArray(stim_ind,:),1,'first');
end

% Append a dateTime to each field with the time in days since the last
% recording. Add the relevant slice of the larger csStimLogicalArray.
for run_ind = 1:length(runList)
  spikeDataBank.(runList{run_ind}).stimPresArray = csStimLogicalArray(:,run_ind);
  spikeDataBank.(runList{run_ind}).dateTime = datetime(extractBetween(spikeDataBank.(runList{run_ind}).dateSubject,1,8),'InputFormat','yyyyMMdd');     %Generate 'daysSinceLastRec' for each field.
end

% find unique recording dates, and the distance between them. Add these
% to the spikeDataBank
allDateTimeVec = struct2cell(structfun(@(x) x.dateTime, spikeDataBank,'UniformOutput', 0));
allDateTimeVec = [allDateTimeVec{:}]';
uniqueDateTimeVec = unique(allDateTimeVec);
daysSinceLastRec = [1000; days(diff(uniqueDateTimeVec))];
for run_ind = 1:length(runList)
  spikeDataBank.(runList{run_ind}).daysSinceLastRec = daysSinceLastRec(spikeDataBank.(runList{run_ind}).dateTime == uniqueDateTimeVec);
end

% use the dateTime and stimulus presentation matrix to find out how long
% in days takes place before a particular showing of a stimulus.
daysSinceLastPres = zeros(size(stimLogicalArray));
for stim_ind = 1:size(stimLogicalArray,1)
  presentationInd = logical(stimLogicalArray(stim_ind,:)); %When was the stim shown
  daysSinceLastPres(stim_ind,presentationInd) = [1000; days(diff(allDateTimeVec(presentationInd)))]; %Duration between those dates in days
end

%Return days since last presentation and the stimulus presentation count to spikeDataBank, arranged in way that matches stim table.
for run_ind = 1:size(stimLogicalArray,2)
  [~, big2SmallInd] = ismember(spikeDataBank.(runList{run_ind}).eventIDs,allStimuliVec);
  spikeDataBank.(runList{run_ind}).daysSinceLastPres = daysSinceLastPres(big2SmallInd,run_ind);
  spikeDataBank.(runList{run_ind}).stimPresCount = csStimLogicalArray(big2SmallInd,run_ind);
end

end

function [spikeDataBank, meanPSTHStruct] = meanPSTH(spikeDataBank, params)
% Function which combines stimulus presentations across all runs in the spikeDataBank. 
% Inputs include spikeDataBank and list of parameters.
meanPSTHStruct = struct();

% Rebuild variables 
%extract the eventIDs field, generate a cell array of unique stimuli
allStimuliVec = struct2cell(structfun(@(x) x.eventIDs, spikeDataBank,'UniformOutput', 0));
allStimuliVec = unique(vertcat(allStimuliVec{:}));

runList = fields(spikeDataBank);

small2BigInd = zeros(length(allStimuliVec), length(runList)); 
for run_ind = 1:length(runList)
  [~, small2BigInd(:,run_ind)] = ismember(allStimuliVec, spikeDataBank.(runList{run_ind}).eventIDs);
end

totalStimPresCount = sum(logical(small2BigInd), 2);

% Load broad label correspondences for plotting or for reassigning labels.
tmp = load(params.stimParamsFilename);
for event_i = 1:length(tmp.paramArray)
  totalEventIDs{event_i} = tmp.paramArray{event_i}{1}; %per the stimParamFile spec, this is the event ID
end
totalEventIDs = totalEventIDs';
[~, paramSortVec] = ismember(allStimuliVec, totalEventIDs);
paramArray = tmp.paramArray(paramSortVec);

%Iterate across stimuli and assign new labels.
allStimuliVecBroad = cell(size(allStimuliVec));
for label_ind = 1:length(allStimuliVec)
  paramStimSet = paramArray{label_ind};
  allStimuliVecBroad{label_ind} = paramStimSet{ismember(paramStimSet,params.broadLabelPool)};
end

if params.zscorePSTHs
  zTag = 'Z-scored';
else
  zTag = '';
end

if params.broadLabel
  % Broad Label - Swaps labels of individual stimuli for broader catagories,
  % as defined in stimParamFile and the parameters.
  allStimuliVec = allStimuliVecBroad';
  figureTitle = 'Broad Labels';
  [uniqueStimLabels, ~, stimIndex] = unique(allStimuliVec);
  uniqueStimLabelCounts = accumarray(stimIndex,1);
  % Find out how many of each of the newly labeled stimuli there are
  % uniqueStimLabelCounts = cell2mat(arrayfun(@(x)length(find(stimIndex == x)), unique(stimIndex), 'Uniform', false));
else
  figureTitle = 'per Stimuli';
  [uniqueStimLabels, ~, stimIndex] = unique(allStimuliVec);
end

% Concatonating PSTHs.
groupingType = {'Unsorted','Units','MUA'};
dataType = {'Bins','Max Value','Max Value Ind','Run Ind'};
%stimPSTH{stim}{grouping}{dataType}
stimPSTH = initNestedCellArray([length(uniqueStimLabels), length(groupingType),length(dataType)],'zeros');
          
for stim_ind = 1:length(allStimuliVec)
  % Find the runs where the stimulus was present, generate a list of them.
  stimRunIndex = small2BigInd(stim_ind,:);
  psthStimIndex = nonzeros(stimRunIndex);
  psthRunIndex = find(stimRunIndex);
  subRunList = runList(psthRunIndex);
  
  % Initialize errors for storing relevant information per stimuli
  % cumulativePSTH{groupingType}{dataType}
  cumulativePSTH = initNestedCellArray([length(groupingType),length(dataType)],'zeros');
  
  % For all runs containing a particular stimuli, retrieve relevant activity vector in each.
  for subRun_ind = 1:length(subRunList) %
    tmpRunStruct = spikeDataBank.(subRunList{subRun_ind});
    for chan_ind = 1:length(tmpRunStruct.psthByImage)
      for unit_ind = 1:length(tmpRunStruct.psthByImage{chan_ind})
        % Retrieve correct PSTH from run
        unitActivity = tmpRunStruct.psthByImage{chan_ind}{unit_ind}(psthStimIndex(subRun_ind),:);
        if sum(unitActivity) ~= 0
          % If desired, Z score PSTHs here based on fixation period activity.
          if params.zscorePSTHs
            fixMean = mean(unitActivity(1:abs(tmpRunStruct.start))); %Find activity during fixation
            fixSD = std(unitActivity(1:abs(tmpRunStruct.start)));
            if fixMean == 0 || fixSD == 0
              % If no spikes take place during the fixation period, use the
              % entire trace to calculate.
              fixMean = mean(unitActivity);
              fixSD = std(unitActivity);
            end
            unitActivity = (unitActivity - fixMean)/fixSD;
          end
          % If only taking peaks during stimulus presentation, store here.
          if params.maxStimOnly
            stimStartInd = abs(tmpRunStruct.start);
            stimEndInd = abs(tmpRunStruct.start) + tmpRunStruct.stimDur;
            [maxVal, maxInd] = max(unitActivity(stimStartInd:stimEndInd));
          else
            [maxVal, maxInd] = max(unitActivity);
          end
          % Concatonate to the correct Matrix (index matching phyzzy convention)
          if unit_ind == 1 % Unsorted
            storeInd = 1;
          elseif unit_ind == length(tmpRunStruct.psthByImage{chan_ind}) % MUA
            storeInd = 3;
          else % Unit
            storeInd = 2;
          end
          cumulativePSTH{storeInd}{1} = [cumulativePSTH{storeInd}{1}; unitActivity];
          cumulativePSTH{storeInd}{2} = [cumulativePSTH{storeInd}{2}; maxVal];
          cumulativePSTH{storeInd}{3} = [cumulativePSTH{storeInd}{3}; maxInd];
          cumulativePSTH{storeInd}{4} = [cumulativePSTH{storeInd}{4}; psthRunIndex(subRun_ind)];
        end
      end
    end
  end
  % Store into Larger cell array to reference
  if isempty(stimPSTH{stimIndex(stim_ind)}{1}{1})
    stimPSTH{stimIndex(stim_ind)} = cumulativePSTH;
  else
    % For overlapping groupings (broad Label), add to sub-structure.
    for group_ind = 1:length(groupingType)
      for data_ind = 1:length(dataType)
        stimPSTH{stimIndex(stim_ind)}{group_ind}{data_ind} = [stimPSTH{stimIndex(stim_ind)}{group_ind}{data_ind}; cumulativePSTH{group_ind}{data_ind}];
      end
    end
  end
end

% Remove stimuli which aren't displayed over params.topStimPresThreshold
% times.
if params.plotTopStim || params.broadLabel
  if params.plotTopStim && ~params.broadLabel
    figureTitle = sprintf('%s with over %d runs', figureTitle, params.topStimPresThreshold);
    topIndex = totalStimPresCount > params.topStimPresThreshold;
  elseif params.broadLabel % For Broad labels, Remove low frequency examples
    figureTitle = sprintf('%s with over 4 stimuli', figureTitle);
    topIndex = uniqueStimLabelCounts > 4;
  end
  stimPSTH = stimPSTH(topIndex);
  uniqueStimLabels = uniqueStimLabels(topIndex);
end

h = gobjects(length(groupingType),length(dataType));
% Cycle through each grouping and data type, plot appropriately
% groupingType = {'Unsorted','Units','MUA'};
% dataType = {'Bins','Max Value','Max Value Ind','Run Ind'};
% stimPSTH{stim}{groupingType}{dataType}

% Region below could be updated to cycle through 'dataType' instead of
% current hardcoded indicies but it doesn't seem worth the effort.
if 0%~params.broadLabel && ~params.plotTopStim
  [broadLabels, ~, broadLabelInd] = unique(allStimuliVecBroad);
  wholeStimPSTH = stimPSTH;
  wholeUniqueStimLabels = uniqueStimLabels;
  meanPSTHStruct.IndStructs{1} = broadLabels;
  meanPSTHStruct.IndStructs{3} = groupingType;
  topMeanPSTHMat = [];
  for broad_ind = 1:length(broadLabels)
    stimPSTH = wholeStimPSTH(broadLabelInd == broad_ind);
    uniqueStimLabels = wholeUniqueStimLabels(broadLabelInd == broad_ind);
    meanPSTHStruct.IndStructs{2}{broad_ind} = uniqueStimLabels;
    for group_ind = 1:length(groupingType)      
      % Plot Histogram of Peak amplitude across PSTHs.
      histoPeakFigTitle = sprintf('%s - Peak PSTH Bin value - %s', broadLabels{broad_ind}, groupingType{group_ind});
      histoIndFigTitle = sprintf('%s - Peak PSTH Times (ms) - %s', broadLabels{broad_ind}, groupingType{group_ind});
      
      h(group_ind,1) = figure('NumberTitle', 'off', 'Name', histoPeakFigTitle);
      hold on
      sgtitle(histoPeakFigTitle)
      
      h(group_ind,2) = figure('NumberTitle', 'off', 'Name', histoIndFigTitle);
      hold on
      sgtitle(histoPeakFigTitle)
      
      maxVal = 0;
      minVal = 100;
      [grandTrace, grandSDTrace] = deal([]);
      [meanPSTH, SDPSTH] = deal(zeros(length(stimPSTH), size(stimPSTH{1}{group_ind}{1},2)));
      
      % Cycle through each stimulus, retrieve the mean and SD of each, plot the
      % histogram of peaks for each.
      perStimCount = zeros(length(stimPSTH),1);
      for stim_ind = 1:length(stimPSTH)
        % Store traces for grand traces, also calculate states for individual
        % stim.
        PSTHes = stimPSTH{stim_ind}{group_ind}{1};
        if size(PSTHes,1) > 1
          runInds = stimPSTH{stim_ind}{group_ind}{4};
          PSTHaboveZero = max(0,PSTHes);
          PSTHsumAct = sum(PSTHaboveZero(:,params.psthPre:end-params.psthPost),2);
          entry = runInds(PSTHsumAct >= prctile(PSTHsumAct,90));
          entryL = length(entry);
          topMeanPSTHMat = [topMeanPSTHMat; entry, repmat(broad_ind, entryL,1), repmat(stim_ind, entryL,1),repmat(group_ind, entryL,1)];
        end
        grandTrace = [grandTrace; PSTHes];
        perStimCount(stim_ind) = size(PSTHes,1);
        meanPSTH(stim_ind,:) = mean(PSTHes,1);
        SDPSTH(stim_ind,:) = std(PSTHes);
        grandSDTrace = [grandSDTrace; SDPSTH(stim_ind,:)];
        
        % Histogram of max bins
        set(0, 'CurrentFigure', h(group_ind,1))
        subplot(ceil(length(stimPSTH)/5),5, stim_ind);
        histogram(stimPSTH{stim_ind}{group_ind}{2}, 20);
        title(sprintf('%s (\x03bc = %s)',uniqueStimLabels{stim_ind}, num2str(round(mean(stimPSTH{stim_ind}{group_ind}{2},1), 2))));
        
        % Histogram of time bins (Inds)
        set(0, 'CurrentFigure', h(group_ind,2))
        subplot(length(stimPSTH),1, stim_ind);
        roundedMaxBinInds = round(stimPSTH{stim_ind}{group_ind}{3}, -1);
        histogram(roundedMaxBinInds, 56); %every 50 ms
        title(sprintf('%s (mode = %s)',uniqueStimLabels{stim_ind}, num2str(mode(roundedMaxBinInds))));
        
        %plot(meanPSTH);
        maxVal = ceil(max([maxVal, max(meanPSTH)]));
        minVal = floor(min([minVal, min(meanPSTH)]));
        
        % Edit uniqueStimLabels for PSTH below
        if group_ind == 1
          uniqueStimLabels{stim_ind} = [uniqueStimLabels{stim_ind}(1:end-4) sprintf(',n = %d', perStimCount(stim_ind))];
        end
        if stim_ind == length(stimPSTH) % Add an 'All Catagory' mean.
          meanPSTH = [meanPSTH; mean(meanPSTH,1)];
          SDPSTH = [SDPSTH; mean(SDPSTH,1)];
          if group_ind == 1
            uniqueStimLabels = [uniqueStimLabels; ['All ' broadLabels{broad_ind} ',n = ' num2str(sum(perStimCount))]];
          end
        end
      end
      if ~exist(params.outputDir, 'dir')
        mkdir(params.outputDir)
      end
      savefig(h(group_ind,1),fullfile(params.outputDir, histoPeakFigTitle))
      savefig(h(group_ind,2),fullfile(params.outputDir, histoIndFigTitle))
      close(h(group_ind,1))
      close(h(group_ind,2))
      
      grandMeanTrace = mean(grandTrace);
      meanPSTHStruct.grandMeanTrace{group_ind}{broad_ind} = grandMeanTrace;
      psthTitle = sprintf('All %s Stimuli - Mean %s PSTH - %s', broadLabels{broad_ind}, zTag, groupingType{group_ind});
      % Plot the Activity PSTH
      h(group_ind,3) = figure('NumberTitle', 'off', 'Name', psthTitle);
      psthAxes = axes();
      psthAxes = plotPSTH(meanPSTH, psthAxes, params, 'color', psthTitle, uniqueStimLabels);
      title(psthTitle)
      grandMeanAxes = axes('YAxisLocation','right','Color', 'none','xtick',[],'xticklabel',[],'xlim',[0 length(grandMeanTrace)]);%,'ytick',[],'yticklabel',[]);
      hold on
      plot(grandMeanAxes, grandMeanTrace,'color','black','lineWidth',4)
      linkprop([psthAxes, grandMeanAxes],{'Position'});
      
      % Plot Standard Deviation PSTH
      grandSDTrace = std(grandTrace);
      psthSDTitle = sprintf('%s - Mean %s PSTH SD Across all %s - %s', broadLabels{broad_ind}, zTag, groupingType{group_ind});
      h(group_ind,4) = figure('NumberTitle', 'off', 'Name', psthSDTitle);
      psthSDAxes = axes();
      psthSDAxes = plotPSTH(SDPSTH, psthSDAxes, params, 'color', psthSDTitle, uniqueStimLabels);
      title(psthSDTitle)
      grandSDAxes = axes('YAxisLocation','right','Color', 'none','xtick',[],'xticklabel',[],'xlim',[0 length(grandSDTrace)]);%,'ytick',[],'yticklabel',[]);
      hold on
      plot(grandSDAxes, grandSDTrace,'color','black','lineWidth',4)
      linkprop([psthSDAxes, grandSDAxes],{'Position'});
      
      savefig(h(group_ind,3),fullfile(params.outputDir, psthTitle))
      savefig(h(group_ind,4),fullfile(params.outputDir, psthSDTitle))
      close(h(group_ind,3))
      close(h(group_ind,4))
    end
  end
else
  for group_ind = 1:length(groupingType)
    % Plot Histogram of Peak amplitude across PSTHs.
    histoPeakFigTitle = sprintf('Peak PSTH Bin value - %s', groupingType{group_ind});
    histoIndFigTitle = sprintf('Peak PSTH Times (ms) - %s', groupingType{group_ind});
    
    h(group_ind,1) = figure('NumberTitle', 'off', 'Name', histoPeakFigTitle);
    hold on
    sgtitle(histoPeakFigTitle)
    
    h(group_ind,2) = figure('NumberTitle', 'off', 'Name', histoIndFigTitle);
    hold on
    sgtitle(histoPeakFigTitle)
    
    maxVal = 0;
    minVal = 100;
    [grandTrace, grandSDTrace] = deal([]);
    [meanPSTH, SDPSTH] = deal(zeros(length(stimPSTH), size(stimPSTH{1}{group_ind}{1},2)));
    
    % Cycle through each stimulus, retrieve the mean and SD of each, plot the
    % histogram of peaks for each.
    for stim_ind = 1:length(stimPSTH)
      % Store traces for grand traces, also calculate states for individual
      % stim.
      grandTrace = [grandTrace; stimPSTH{stim_ind}{group_ind}{1}];
      meanPSTH(stim_ind,:) = mean(stimPSTH{stim_ind}{group_ind}{1},1);
      grandSDTrace = [grandSDTrace; SDPSTH(stim_ind,:)];
      SDPSTH(stim_ind,:) = std(stimPSTH{stim_ind}{group_ind}{1});
      
      % Histogram of max bins
      set(0, 'CurrentFigure', h(group_ind,1))
      subplot(ceil(length(stimPSTH)/5),5, stim_ind);
      hist(stimPSTH{stim_ind}{group_ind}{2}, 20);
      title(sprintf('%s (\x03bc = %s)',uniqueStimLabels{stim_ind}, num2str(round(mean(stimPSTH{stim_ind}{group_ind}{2},1), 2))));
      
      % Histogram of time bins (Inds)
      set(0, 'CurrentFigure', h(group_ind,2))
      subplot(length(stimPSTH),1, stim_ind);
      roundedMaxBinInds = round(stimPSTH{stim_ind}{group_ind}{3}, -1);
      hist(roundedMaxBinInds, 56); %every 50 ms
      title(sprintf('%s (mode = %s)',uniqueStimLabels{stim_ind}, num2str(mode(roundedMaxBinInds))));
      
      %plot(meanPSTH);
      maxVal = ceil(max([maxVal, max(meanPSTH)]));
      minVal = floor(min([minVal, min(meanPSTH)]));
    end
    savefig(h(group_ind,1),fullfile(params.outputDir, histoPeakFigTitle))
    savefig(h(group_ind,2),fullfile(params.outputDir, histoIndFigTitle))
    close(h(group_ind,1))
    close(h(group_ind,2))
    
    grandMeanTrace = mean(grandTrace);
    psthTitle = sprintf('Mean %s PSTH Across all %s - %s', zTag, groupingType{group_ind}, figureTitle);
    if params.broadLabel
      newOrder = [1:3,5,7,4,6,8:10]; %Applies to broad labels, puts Control stimuli at bottom.
    else
      newOrder = 1:size(meanPSTH,1);
    end
    % Plot the Activity PSTH
    h(group_ind,3) = figure('NumberTitle', 'off', 'Name', psthTitle);
    psthAxes = axes();
    psthAxes = plotPSTH(meanPSTH(newOrder,:), psthAxes, params, 'color', psthTitle, uniqueStimLabels(newOrder));
    title(psthTitle)
    grandMeanAxes = axes('YAxisLocation','right','Color', 'none','xtick',[],'xticklabel',[],'xlim',[0 length(grandMeanTrace)]);%,'ytick',[],'yticklabel',[]);
    hold on
    plot(grandMeanAxes, grandMeanTrace,'color','black','lineWidth',4)
    linkprop([psthAxes, grandMeanAxes],{'Position'});
    
    % Plot Standard Deviation PSTH
    grandSDTrace = std(grandTrace);
    psthSDTitle = sprintf('Mean %s PSTH Std Deviation Across all %s - %s', zTag, groupingType{group_ind}, figureTitle);
    h(group_ind,4) = figure('NumberTitle', 'off', 'Name', psthSDTitle);
    psthSDAxes = axes();
    psthSDAxes = plotPSTH(SDPSTH(newOrder,:), psthSDAxes, params, 'color', psthSDTitle, uniqueStimLabels(newOrder));
    title(psthSDTitle)
    grandSDAxes = axes('YAxisLocation','right','Color', 'none','xtick',[],'xticklabel',[],'xlim',[0 length(grandSDTrace)]);%,'ytick',[],'yticklabel',[]);
    hold on
    plot(grandSDAxes, grandSDTrace,'color','black','lineWidth',4)
    linkprop([psthSDAxes, grandSDAxes],{'Position'});
    
    savefig(h(group_ind,3),fullfile(params.outputDir, psthTitle))
    savefig(h(group_ind,4),fullfile(params.outputDir, psthSDTitle))
    close(h(group_ind,3))
    close(h(group_ind,4))
  end
end

meanPSTHStruct.topMeanPSTHMat = topMeanPSTHMat;

end

function spikeDataBank = slidingWindowANOVA(spikeDataBank,params)
% Perform sliding scale ANOVA, calculate Omega at each bin.

% Generate variables needed
runList = fields(spikeDataBank);
binSize = params.binSize;
binStep = params.binStep;
target = params.target;
Omega = params.Omega;
stimParamFile = params.stimParamFile;

% Step 1 - generate bin times and spike rates, and proper memberships to groups.
if ~isfield(spikeDataBank.(runList{1}), 'epochRates')
  for run_ind = 1:length(runList)
    runStruct = spikeDataBank.(runList{run_ind});
    starts = (runStruct.start:binStep:(runStruct.end - binSize))';
    ends = (runStruct.start+binSize:binStep:(runStruct.end))';
    spikeDataBank.(runList{run_ind}).epochs = [starts,ends];
    spikeDataBank.(runList{run_ind}).epochRates = cell(length(starts),1);
    for bin_ind = 1:length(starts)
      [spikeDataBank.(runList{run_ind}).epochRates{bin_ind}, ~, ~] = spikeCounter(spikeDataBank.(runList{run_ind}).spikesByEvent, starts(bin_ind), ends(bin_ind));
    end
    for group_ind = 1:length(target)
      groupDef = target{group_ind};
      nestStrCmp = @(x) any(strcmp(x, groupDef));
      spikeDataBank.(runList{run_ind}).catagoryInd(:,group_ind) = cell2mat(cellfun(nestStrCmp, runStruct.eventCategories,'UniformOutput',0));
    end
  end
  saveSpikeDataBank(spikeDataBank, 2, 'save',params.outputDir);
else
  fprintf('Sliding windows rates already calculated, continuing... \n');
end


% Step 2 - Perform ANOVA, Omega calculation, and store values.
% performs an ANOVA on rates across a trial, starting at trial time 0, in some predefined steps.

for run_ind = 1:length(runList)
  % Check if pValues have already been recorded for this run.
  if 1%~isfield(spikeDataBank.(runList{length(run_ind)}),'pVec')
    % Initialize relevant Structures
    [pVec, errVec, nullOmegaVec, nullVec] = deal(initNestedCellArray(spikeDataBank.(runList{run_ind}).epochRates{1}, 'ones', [length(spikeDataBank.(runList{run_ind}).epochs), length(target)], 2)); % Initialize each p value array.
    omegaVec = initNestedCellArray(spikeDataBank.(runList{run_ind}).epochRates{1}, 'zeros', [length(spikeDataBank.(runList{run_ind}).epochs), length(target)], 2);
    [maxOmegaVec] = deal(initNestedCellArray(spikeDataBank.(runList{run_ind}).epochRates{1}, 'zeros', [1, length(target)], depth)); % Initialize each p value array.
    if length(unique(spikeDataBank.(runList{run_ind}).catagoryInd)) > 1 %Only run tests where you have members in each group.
      for bin_ind = 1:length(spikeDataBank.(runList{run_ind}).epochs)
        for chan_ind = 1:length(spikeDataBank.(runList{run_ind}).epochRates{bin_ind})
          for unit_ind = 1:length(spikeDataBank.(runList{run_ind}).epochRates{bin_ind}{chan_ind})
            unitResponsePerEvent = spikeDataBank.(runList{run_ind}).epochRates{bin_ind}{chan_ind}{unit_ind};
            catagortyInd = spikeDataBank.(runList{run_ind}).catagoryInd;
            %unitData{event}.rates = trial*1
            for target_ind = 1:length(target)
              if length(unique(catagortyInd(:,target_ind))) == 1
                break % If there is only 1 label type, there is no comparison to be made.
              end
              [trialSpikes, trialLabels]  = deal([]);
              % grab the relevant events
              targetInd = catagortyInd(:,target_ind);
              targetSpikes = unitResponsePerEvent(targetInd);
              otherSpikes = unitResponsePerEvent(~targetInd);
              % Initialize relevant vecotrs
              spikeGroups = {targetSpikes otherSpikes};
              spikeGroupLabels ={(target{target_ind}) (['non-' target{target_ind}])};
              % Cluster and reshape the arrays properly
              for group_i = 1:length(spikeGroups)
                tmp = spikeGroups{group_i};
                tmp = [tmp{:}];
                dataVec = vertcat(tmp.rates);
                labelVec = repmat(spikeGroupLabels(group_i), length(dataVec),1);
                trialSpikes = vertcat(trialSpikes,dataVec);
                trialLabels = vertcat(trialLabels, labelVec);
              end
              % Check for social v non-social
              [pVec{chan_ind}{unit_ind}(bin_ind,target_ind), pStatsTable, ~] = anovan(trialSpikes,{trialLabels},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
              top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
              bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
              omegaVec{chan_ind}{unit_ind}(bin_ind,target_ind) = top/bottom;
              % Perform Calculations on scrambles
              [nullPVec, nullOmegaVecSingle] = deal(zeros(1,params.scrambleCount));
              for rand_ind = 1:params.scrambleCount
                [nullPVec(rand_ind), pStatsTable, ~] = anovan(trialSpikes,{trialLabels(randperm(length(trialLabels)))},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
                top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
                bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
                nullOmegaVecSingle(rand_ind) = top/bottom;
              end
              nullVec{chan_ind}{unit_ind}(bin_ind,target_ind) = mean(nullPVec);
              errVec{chan_ind}{unit_ind}(bin_ind,target_ind) = std(nullPVec)/length(nullPVec);
              nullOmegaVec{chan_ind}{unit_ind}(bin_ind,target_ind) = mean(nullOmegaVecSingle);
              % On the last bin, do the desired stimulus wide calculations
              % for collected traces.
              if bin_ind == length(spikeDataBank.(runList{run_ind}).epochs)
                maxOmegaVec{chan_ind}{unit_ind} = max(omegaVec{chan_ind}{unit_ind});
              end
            end
          end
        end
      end
    else
      disp('Skipping')
    end
    spikeDataBank.(runList{run_ind}).pVec = pVec;
    spikeDataBank.(runList{run_ind}).nullPVec = nullVec;
    spikeDataBank.(runList{run_ind}).maxOmegaVec = maxOmegaVec;
    spikeDataBank.(runList{run_ind}).omegaVec = omegaVec;
    spikeDataBank.(runList{run_ind}).nullOmegaVec = nullOmegaVec;
    % Plot the results for each unit seen
    if params.plotANOVA
      for chan_ind = 1:length(pVec)
        for unit_ind = 1:length(pVec{chan_ind})
          if unit_ind == 1
            ANOVAvarName = ['Ch' num2str(chan_ind) ' Unsorted - SocVsNonSoc'];
          elseif unit_ind == length(pVec{chan_ind})
            ANOVAvarName = ['Ch' num2str(chan_ind) ' MUA - SocVsNonSoc'];
          else
            ANOVAvarName = ['Ch' num2str(chan_ind) ' U' num2str(unit_ind-1) ' - SocVsNonSoc'];
          end
          if ~any(any(isnan(pVec{chan_ind}{unit_ind})))
            k = figure();
            plot(pVec{chan_ind}{unit_ind},'linewidth',2)
            hold on
            xlim([0,size(pVec{chan_ind}{unit_ind},1)]);
            ylim([0,1]);
            plot([0,size(pVec{chan_ind}{unit_ind},1)],[0.05, 0.05],'k','linewidth',3)
            fracSig = round(sum(pVec{chan_ind}{unit_ind} < 0.05)/length(pVec{chan_ind}{unit_ind}), 3, 'significant');
            fragSigNull = round(sum(pVec{chan_ind}{unit_ind} < 0.4)/length(pVec{chan_ind}{unit_ind}), 3, 'significant');
            nullLines = cell(length(target),1);
            for null_ind = 1:length(target)
              nullLines{null_ind} = mseb(1:length(nullVec{chan_ind}{unit_ind}),nullVec{chan_ind}{unit_ind}(:,null_ind)', errVec{chan_ind}{unit_ind}(:,null_ind)');
              nullLines{null_ind}.patch.FaceAlpha = '0.5';
            end
            % Create Legend and Title
            titleString = sprintf('Sliding Scale ANOVA - %s',ANOVAvarName);
            title(titleString)
            legendText = cell(length(target),1);
            for leg_ind = 1:length(target)
              legendText{leg_ind} = sprintf('%s (%s;%s)', target{leg_ind}, num2str(fracSig(leg_ind)),num2str(fragSigNull(leg_ind)));
            end
            legend(legendText);
            % Save and close
            savefig(k, fullfile(spikeDataBank.(runList{run_ind}).figDir,titleString))
            close(k)
          end
        end
      end
    end
    % Every 20 runs, save progress back to the files
    if mod(run_ind,20) == 0 || run_ind == length(runList)
      disp(run_ind)
      saveSpikeDataBank(spikeDataBank, 2, 'save',params.outputDir);
    end
  else
    fprintf('spikeDataBank field %d already has pVec, moving to next field... \n', run_ind)
  end
end

fprintf('ANOVA Omega Calculations finished... \n')

% Count Results of ANOVA across all units, count stretches of significant
% bins.
totalUnitCount = 0;
totalChannelCount = 0;
[sigBinCountUnit, sigBinCountUnsorted, sigBinCountMUA, ...
  nulSigBinCountUnit, nulSigBinCountUnsorted, nulSigBinCountMUA] = deal(zeros(length(spikeDataBank.(runList{1}).epochs), length(target)));
sigBinCountTotal = [];
targetRunLengths = struct();
for targ_i = 1:length(target)
  targetRunLengths.(target{targ_i}) = [];
end

for run_ind = 1:length(runList)
  for chan_ind = 1:length(spikeDataBank.(runList{run_ind}).pVec)
    totalChannelCount = totalChannelCount + 1;
    for unit_ind = 1:length(spikeDataBank.(runList{run_ind}).pVec{chan_ind})
      unitLen = length(spikeDataBank.(runList{run_ind}).pVec{chan_ind});
      uPVec = spikeDataBank.(runList{run_ind}).pVec{chan_ind}{unit_ind};
      uNullVec =  spikeDataBank.(runList{run_ind}).nullPVec{chan_ind}{unit_ind};
      % Check for significant bins
      tmpSigCount = uPVec < 0.05;
      tmpNullSigCount = uNullVec < 0.05;
      % Add to relevant structures
      if unit_ind == 1
        sigBinCountUnsorted = tmpSigCount + sigBinCountUnsorted;
        nulSigBinCountUnsorted = tmpNullSigCount + nulSigBinCountUnsorted;
      elseif unit_ind == unitLen
        sigBinCountMUA = tmpSigCount + sigBinCountMUA;
        nulSigBinCountMUA = tmpNullSigCount + nulSigBinCountMUA;
      else
        totalUnitCount = totalUnitCount + 1;
        sigBinCountUnit = tmpSigCount + sigBinCountUnit;
        nulSigBinCountUnit = tmpNullSigCount +nulSigBinCountUnit;
        sigBinCountTotal = [sigBinCountTotal; sum(tmpSigCount)];
        % Keep count of consecutive bins for units
        for targ_i = 1:size(tmpSigCount,2)
          starts = find(diff([0; tmpSigCount(:,targ_i)]) == 1);
          ends = find(diff([tmpSigCount(:,targ_i); 0]) == -1)+1;
          runLengths = ends - starts;
          targetRunLengths.(target{targ_i}) = [targetRunLengths.(target{targ_i}); runLengths];
        end
      end
    end
  end
end

% Plot Results
% Fig 1 - Soc vs Non-Soc significance bins
target = {'socialInteraction','agents','interaction'};
allUnitTraces = [sigBinCountUnit, nulSigBinCountUnit];
allMUATraces = [sigBinCountMUA, nulSigBinCountMUA];
allUnsortedTraces = [sigBinCountUnsorted,nulSigBinCountUnsorted];
legendCells = cell(length(target)*2,1);
for legend_i = 1:length(target)
  legendCells{legend_i} = target{legend_i};
  legendCells{legend_i+length(target)} = ['Label scramble ' target{legend_i}];
end

figure
subplot(3,1,1)
plot(allUnitTraces,'Linewidth',3);
legend(legendCells);
ylim([0 totalUnitCount/5]);
xlim([0 length(allUnitTraces)])
title('Significant Units per Bin')
subplot(3,1,2)
plot(allMUATraces,'Linewidth',3);
legend(legendCells);
ylim([0 totalUnitCount/5]);
xlim([0 length(allUnitTraces)])
title('Significant MUA per Bin')
subplot(3,1,3)
plot(allUnsortedTraces,'Linewidth',3);
legend(legendCells);
ylim([0 totalUnitCount/5]);
xlim([0 length(allUnitTraces)])
title('Significant Unsorted per Bin')

% Fig 2 - Numbers of bins per stimuli, length of stretches
figure()
for ii = 1:length(target)
  %Plot significant bin count per unit
  subplot(length(target), 2, (ii*2)-1)
  histogram(sigBinCountTotal(:,ii),50)
  title(sprintf('Number of bins per unit (%s)',target{ii}))
  %Plot stretch duration per unit
  subplot(length(target), 2, (ii * 2))
  histogram(targetRunLengths.(target{ii}))
  title(sprintf('Length of significant bin runs per unit (%s)',target{ii}))
end

% Fig 3 - Plot Omega curves, save to Run folder.
allMaxOmegas = [];
figData.binSize = binSize; %figData required to save figure.
figData.binStep = binStep;
for run_ind = 1:length(runList)
  omegaVec = spikeDataBank.(runList{run_ind}).omegaVec;
  for chan_ind = 1:length(omegaVec)
    for unit_ind = 1:length(omegaVec{chan_ind})
      if unit_ind == 1
        ANOVAvarName = ['Ch' num2str(chan_ind) ' Unsorted'];
      elseif unit_ind == length(omegaVec{chan_ind})
        ANOVAvarName = ['Ch' num2str(chan_ind) ' MUA'];
      else
        ANOVAvarName = ['Ch' num2str(chan_ind) ' unit ' num2str(unit_ind-1)];
        allMaxOmegas = [allMaxOmegas; spikeDataBank.(runList{run_ind}).maxOmegaVec{chan_ind}{unit_ind}];
      end
      figure()
      plot(omegaVec{chan_ind}{unit_ind},'linewidth',2)
      hold on
      xlim([0,size(omegaVec{chan_ind}{unit_ind},1)]);
      ylim([0,0.2]);
      title(sprintf('Sliding Window ANOVA Omega - %s, %d ms bin', ANOVAvarName, binSize))
      legendText = cell(length(target),1);
      for leg_ind = 1:length(target)
        legendText{leg_ind} = sprintf('%s', target{leg_ind});
      end
      legend(legendText);
      starts = spikeDataBank.(runList{run_ind}).epochs(:,1);
      xticks(1:10:length(starts))
      xticklabels(starts(1:10:length(starts)));
      fileName = sprintf('Omega Curve - %s, %d ms bins, %d ms step', ANOVAvarName, binSize, binStep);
      savePath = [spikeDataBank.(runList{run_ind}).figDir filesep];
      saveFigure(savePath, fileName, figData, 1, 0, 0, runList{run_ind}, 'close')
    end
  end
end

%Distribution of peak sensitivities 
for ii = 1:size(allMaxOmegas,2)
  figure
  hist(allMaxOmegas(:,ii),20);
  title(target{ii});
end

end

function [spikeDataBank, frameFiringStruct]  = frameFiringRates(spikeDataBank,params)
% Generates means and distributions based on what is being looking at.

% Generate variables needed
runList = fields(spikeDataBank);

% Step 1 - generate bin times and spike rates.
if ~isfield(spikeDataBank.(runList{end}), 'frameFiringRates')
  for run_ind = 1:length(runList)
    runStruct = spikeDataBank.(runList{run_ind});
    if length(unique(cellfun('length',runStruct.attendedObjData.frameStartInd))) == 1 % If all the videos are the same number of frames
      starts = runStruct.attendedObjData.frameStartInd{1}'+params.delay;
      ends = runStruct.attendedObjData.frameEndInd{1}'+params.delay;
      spikeDataBank.(runList{run_ind}).frameTimes = [starts,ends];
      spikeDataBank.(runList{run_ind}).frameFiringRates = cell(length(starts),1);
      frameFiringRatesTmp = cell(length(starts),1);
      for frame_ind = 1:length(starts)
        % spikeDataBank.run.framingFiringRates{epoch/bin}{channel}{unit}{stim}
        [frameFiringRatesTmp{frame_ind}, ~, ~] = spikeCounter(spikeDataBank.(runList{run_ind}).spikesByEvent, starts(frame_ind), ends(frame_ind));
      end
    else
      error('Different stimuli contain different number of frames. Implement different spikeCounting method.')
    end
    % Step 1.5 - Rearrange frameFiringRatesTmp to match attendedObjVect data {channel}{unit}{stimuli}(trials*frames)
    frameCount = length(frameFiringRatesTmp);
    trialCount = length(frameFiringRatesTmp{1}{1}{1}{1}.counts);
    frameFiringRates = initNestedCellArray(frameFiringRatesTmp{1},'zeros',[trialCount, frameCount]);
    for chan_ind = 1:length(frameFiringRatesTmp{1})
      for unit_ind = 1:length(frameFiringRatesTmp{1}{chan_ind})
        frameFiringRatesUnitTmp = initNestedCellArray(runStruct.attendedObjData.attendedObjVect, 'zeros', [size(runStruct.attendedObjData.attendedObjVect{1})],1);
        for frame_ind = 1:length(frameFiringRatesTmp)
          for stim_ind = 1:length(frameFiringRatesTmp{frame_ind}{chan_ind}{unit_ind})
            if frame_ind == 1
              frameFiringRatesUnitTmp{stim_ind} = zeros(size(runStruct.attendedObjData.attendedObjVect{stim_ind}));
            end
            if params.useRates
            frameFiringRatesUnitTmp{stim_ind}(:,frame_ind) = frameFiringRatesTmp{frame_ind}{chan_ind}{unit_ind}{stim_ind}.rates;
            else
              frameFiringRatesUnitTmp{stim_ind}(:,frame_ind) = frameFiringRatesTmp{frame_ind}{chan_ind}{unit_ind}{stim_ind}.counts;
            end
          end
        end
        frameFiringRates{chan_ind}{unit_ind} = frameFiringRatesUnitTmp;
      end
    end
    spikeDataBank.(runList{run_ind}).frameFiringRates = frameFiringRates;
    disp(run_ind)
  end
  saveSpikeDataBank(spikeDataBank, 2, 'save',params.outputDir);
else
  fprintf('Frame firing rates already calculated., continuing... \n');
end

% Step 2 - Go through each run, sum frame counts/rates associated with the
% specific objects being attended. Plot individual figures if desired.
dataType = {'Bins','Means','Max Value','Max Value Ind'};
objList = spikeDataBank.(runList{1}).attendedObjData.objList;
objListBroad = {'Face','Body','Hand','GazeFollow','Object','Bkg'};

if params.broadLabels
  objListPlot = objListBroad;
else
  objListPlot = objList;
end

% Structure to reference
% frameFiringRates{channel}{unit}{stim}(trial,frame)

% Structure to Generate
% ObjFrameFiringRates{channel}{unit}{stim}{obj}{dataType}

channelUnitMat = [];
if ~isfield(spikeDataBank.(runList{end}), 'ObjFrameFiringRates') 
for run_ind = 1:length(runList)
  disp(run_ind)
  frameFiringRates = spikeDataBank.(runList{run_ind}).frameFiringRates;
  attendedObjVect = spikeDataBank.(runList{run_ind}).attendedObjData.attendedObjVect;
  eventIDs = spikeDataBank.(runList{run_ind}).eventIDs;
  ObjFrameFiringRates = initNestedCellArray(spikeDataBank.(runList{run_ind}).frameFiringRates,'cell',[0,0],3);
  chanCount = 0;
  unitCount = 0;
  
  % Per Stimuli Plot
  for channel_ind = 1:length(ObjFrameFiringRates)
    chanCount = chanCount + 1;
    for unit_ind = 1:length(ObjFrameFiringRates{channel_ind})
      unitCount = unitCount + 1;
      for stim_ind = 1:length(ObjFrameFiringRates{channel_ind}{unit_ind})
        stimAttendedObj = attendedObjVect{stim_ind};
        spikeStruct = frameFiringRates{channel_ind}{unit_ind}{stim_ind};
        ObjFrameFiringRatesStim = initNestedCellArray([length(objListPlot), length(dataType)],'zeros');
        for obj_ind = 1:length(objList)
          objRates = spikeStruct(strcmp(stimAttendedObj, objList{obj_ind}));
          %           Z-score if needed
          %             if params.zscorePSTHs
          %               fixMean = mean(unitActivity(1:abs(tmpRunStruct.start))); %Find activity during fixation
          %               fixSD = std(unitActivity(1:abs(tmpRunStruct.start)));
          %               if fixMean == 0 || fixSD == 0
          %                 fixMean = mean(unitActivity);
          %                 fixSD = std(unitActivity);
          %               end
          %               unitActivity = (unitActivity - fixMean)/fixSD;
          %             end
          
          % Identify correct object group, when using broad labels.
          if params.broadLabels
            switch find(strcmp(objList,objList{obj_ind}))
              case {1,7};         objStoreInd = 1;
              case {2,8};         objStoreInd = 2;
              case {3,4,9,10};    objStoreInd = 3;
              case {5,11};        objStoreInd = 4;
              case {6,12};        objStoreInd = 5;
              case 13;            objStoreInd = 6;
            end
          else
            objStoreInd = obj_ind;
          end
          if ~isempty(objRates)
            ObjFrameFiringRatesStim{objStoreInd}{1} = [ObjFrameFiringRatesStim{objStoreInd}{1}; objRates];
          end
        end
        for obj_ind = 1:length(objListPlot) % Once all the counts are gathered, calculate means, max.
          if ~isempty(ObjFrameFiringRatesStim{obj_ind}{1})
            [maxVal, maxInd] = max(ObjFrameFiringRatesStim{obj_ind}{1});
            ObjFrameFiringRatesStim{obj_ind}{2} = mean(ObjFrameFiringRatesStim{obj_ind}{1});
            ObjFrameFiringRatesStim{obj_ind}{3} = maxVal;
            ObjFrameFiringRatesStim{obj_ind}{4} = maxInd;
          end
        end
        ObjFrameFiringRates{channel_ind}{unit_ind}{stim_ind} = ObjFrameFiringRatesStim;
      end
      if params.plotRuns
        % Plot in large subplot grid.
        figTitle = sprintf('%s - Obj firing rates, Ch%d', eventIDs{stim_ind}, channel_ind);
        h = figure('Name', figTitle);
        sgtitle(figTitle)
        for unit_ind = 1:length(frameFiringRates{channel_ind})
          for obj_ind = 1:length(objListPlot)
            if unit_ind == 1;           unitTitle = 'Unsorted';
            elseif unit_ind == length(frameFiringRates{channel_ind});    unitTitle = 'MUA';
            else;                       unitTitle = sprintf('Unit %d', unit_ind-1);
            end
            subplot(length(frameFiringRates{channel_ind}), length(objListPlot),(((unit_ind-1)*length(objListPlot))+obj_ind))
            histogram(ObjFrameFiringRates{stim_ind}{obj_ind}{unit_ind}{1}, 3)
            countMean = mean(ObjFrameFiringRates{stim_ind}{obj_ind}{unit_ind}{1});
            title(sprintf('%s (\x03bc  = %s)',objListPlot{obj_ind},num2str(round(countMean,2))));
            if obj_ind == 1
              ylabel(unitTitle)
            end
          end
        end
        savefig(fullfile(spikeDataBank.(runList{run_ind}).figDir, [figTitle '.fig']));
        close(h)
      end
    end
  end
  % Structure is ObjFrameFiringRates{stim}{obj}{channel}{unit}{dataType}
  spikeDataBank.(runList{run_ind}).ObjFrameFiringRates = ObjFrameFiringRates;
  channelUnitMat = [channelUnitMat; [run_ind, chanCount, unitCount]];
end
saveSpikeDataBank(spikeDataBank, 2, 'save',params.outputDir);
else
  disp('ObjFrameFiringRates already calculated')
end


% Step 3 - Generate vectors with data from all runs, organized as follows
% from ObjFrameFiringRates{channel}{unit}{stim}{obj}{dataType} to
% objFrameFiringRatesTotal{stim}{obj}{groupingType}{dataType}
groupingType = {'Unsorted','Units','MUA'};
dataType = {'Means','Max Value','Max Value Ind','Run Ind'};

% Pooling across runs requires vector of all stim, extract the eventIDs field, generate a cell array of unique stimuli
allStimuliVec = struct2cell(structfun(@(x) x.eventIDs, spikeDataBank,'UniformOutput', 0));
[allStimuliVec, ~, ic] = unique(vertcat(allStimuliVec{:}));
allStimuliVecCounts = accumarray(ic,1);
objFrameFiringRatesTotal = initNestedCellArray([length(allStimuliVec),length(objListPlot), length(groupingType), length(dataType)],'zeros');

for run_ind = 1:length(runList)
  disp(run_ind)
  stimObjData = spikeDataBank.(runList{run_ind}).ObjFrameFiringRates;
  [~, grandStimInd] = ismember(spikeDataBank.(runList{run_ind}).eventIDs, allStimuliVec);
  for chan_ind = 1:length(stimObjData)
    for unit_ind = 1:length(stimObjData{chan_ind})
      if unit_ind == 1;  groupInd = 1;  %Unsorted
      elseif unit_ind == length(stimObjData{chan_ind}) % MUA
        groupInd = 3;        %MUA
      else;          groupInd = 2;     %Unit
      end
      % Go through stimuli present, concatonate to grand matrix.
      for stim_ind = 1:length(grandStimInd)
        for obj_ind = 1:length(objFrameFiringRatesTotal{stim_ind})
          % Pull Stats, Store in appropriate matrix.
          objFrameFiringRatesTotal{grandStimInd(stim_ind)}{obj_ind}{groupInd}{1} = [objFrameFiringRatesTotal{grandStimInd(stim_ind)}{obj_ind}{groupInd}{1}; stimObjData{chan_ind}{unit_ind}{stim_ind}{obj_ind}{2}];
          objFrameFiringRatesTotal{grandStimInd(stim_ind)}{obj_ind}{groupInd}{2} = [objFrameFiringRatesTotal{grandStimInd(stim_ind)}{obj_ind}{groupInd}{2}; stimObjData{chan_ind}{unit_ind}{stim_ind}{obj_ind}{3}];
          objFrameFiringRatesTotal{grandStimInd(stim_ind)}{obj_ind}{groupInd}{3} = [objFrameFiringRatesTotal{grandStimInd(stim_ind)}{obj_ind}{groupInd}{3}; stimObjData{chan_ind}{unit_ind}{stim_ind}{obj_ind}{4}];
          if ~isnan(stimObjData{chan_ind}{unit_ind}{stim_ind}{obj_ind}{2})
            objFrameFiringRatesTotal{grandStimInd(stim_ind)}{obj_ind}{groupInd}{4} = [objFrameFiringRatesTotal{grandStimInd(stim_ind)}{obj_ind}{groupInd}{4}; run_ind];
          end
          assert(length(objFrameFiringRatesTotal{grandStimInd(stim_ind)}{obj_ind}{groupInd}{2}) == length(objFrameFiringRatesTotal{grandStimInd(stim_ind)}{obj_ind}{groupInd}{4}));
        end
      end
    end
  end
end

if params.broadLabels
  % Broad Label - Swaps labels of individual stimuli for broader catagories,
  % as defined in stimParamFile and the parameters.
  figureTitle = 'Broad Labels';
  tmp = load(params.stimParamsFilename);
  for event_i = 1:length(tmp.paramArray)
    totalEventIDs{event_i} = tmp.paramArray{event_i}{1}; %per the stimParamFile spec, this is the event ID
  end
  totalEventIDs = totalEventIDs';
  [~, paramSortVec] = ismember(allStimuliVec, totalEventIDs);
  paramArray = tmp.paramArray(paramSortVec);
  
  %Iterate across stimuli and assign new labels.
  allStimuliVecTmp = cell(size(allStimuliVec));
  for label_ind = 1:length(allStimuliVec)
    paramStimSet = paramArray{label_ind};
    allStimuliVecTmp{label_ind} = paramStimSet{ismember(paramStimSet,params.broadLabelPool)};
  end
  allStimuliVec = allStimuliVecTmp';
  [uniqueStimLabels, ~, stimIndex] = unique(allStimuliVec);
  
  % Find out how many of each of the newly labeled stimuli there are
  uniqueStimLabelCounts = cell2mat(arrayfun(@(x)length(find(stimIndex == x)), unique(stimIndex), 'Uniform', false));
else
  figureTitle = 'per Stimuli';
  [uniqueStimLabels, ~, stimIndex] = unique(allStimuliVec);
end

% Step 4 - Generate a table for more straight forward referencing with the following
% columns - {'Data', 'Stim_ind', 'Obj_ind', 'group_ind', 'data_ind', 'Run_ind'}
% Data = Value
% Stim_ind = index of value's stim in allStimuliVec (may be broadLabels or
% not)
% Obj_ind = index of value's stim in objListPlot.
% group_ind = {'Unsorted','Units','MUA'};
% data_ind = {'Means','Max Value','Max Value Ind','Run Ind'};

objFrameFiringRatesTotalMat = [];
for stim_ind = 1:length(uniqueStimLabels)
  for obj_ind = 1:length(objFrameFiringRatesTotal{1})
    for group_ind = 1:length(objFrameFiringRatesTotal{1}{1})
      % Relies on Ind 4 being index of run in runList
      runInd = objFrameFiringRatesTotal{stim_ind}{obj_ind}{group_ind}{4};
      for data_ind = 1:length(objFrameFiringRatesTotal{1}{1}{1})-1
        entry = objFrameFiringRatesTotal{stim_ind}{obj_ind}{group_ind}{data_ind};
        if sum(isnan(entry)) ~= length(entry)
          entryL = length(entry);
          newEntries = [entry, repmat(stim_ind, entryL,1), repmat(obj_ind, entryL,1), repmat(group_ind, entryL,1), repmat(data_ind, entryL,1), runInd];
          objFrameFiringRatesTotalMat = [objFrameFiringRatesTotalMat; newEntries];
        end
      end
    end
  end
end
% table w/ {'value', 'stim_ind', 'obj_ind', 'group_ind', 'data_ind', 'run_ind'} columns.
objFrameFiringRatesTable = array2table(objFrameFiringRatesTotalMat);
objFrameFiringRatesTable.Properties.VariableNames = {'value', 'stim_ind', 'obj_ind', 'group_ind', 'data_ind', 'run_ind'};

% Step 5 - Generate figures
% Produces 72 images

% Matrix below will store the top 10th percentile of both maxes and means
top10PrcStimMat = [];
for stim_ind = 1:length(uniqueStimLabels)
  for data_ind = 1:length(dataType(1:2))
    for group_ind = 1:length(groupingType)
      % Fig 1 - 'Chasing, Per Object Rates Means - MUA'

      figTitle = sprintf('%s, Per Object Rates, %s - %s', uniqueStimLabels{stim_ind}, dataType{data_ind}, groupingType{group_ind});
      figFilePath = fullfile(params.outputDir, figTitle);
      valInds = ((objFrameFiringRatesTable.data_ind == data_ind) + (objFrameFiringRatesTable.group_ind == group_ind)) == 2;
      objLabel = objFrameFiringRatesTable.obj_ind(valInds);
      objMean = objFrameFiringRatesTable.value(valInds); %objMean is only actually the mean when it is data_ind == 1. Otherwise it is Max.
      runInds = objFrameFiringRatesTable.run_ind(valInds);
      if ~exist([figFilePath, '.fig'],'file')
        h = figure('Name', figTitle, 'NumberTitle', 'off');
        sgtitle(figTitle)
        hold on
        uniqueObjLabels = unique(objLabel);
        subplot(2,length(uniqueObjLabels),[1:length(uniqueObjLabels)])
        boxplot(objMean,objLabel,'Labels',objListPlot(uniqueObjLabels), 'Symbol', 'o')
        for obj_ind = 1:length(uniqueObjLabels)
          subplot(2,length(uniqueObjLabels),obj_ind+length(uniqueObjLabels))
          singleObjMeans = objMean(objLabel == uniqueObjLabels(obj_ind));
          histogram(singleObjMeans, 20)
          title(sprintf('%s (\x03bc  = %s)',objListPlot{uniqueObjLabels(obj_ind)},num2str(round(mean(singleObjMeans), 2))));
        end
        linkaxes([h.Children(1:length(uniqueObjLabels))],'xy')
        savefig(fullfile(params.outputFigDir, figTitle))
        close(h)
      end
      % Collect run Indices for 90th percentile
      entry = runInds(objMean>=prctile(objMean,90));
      entryL = length(entry);
      newEntries = [entry, repmat(stim_ind, entryL,1), repmat(data_ind, entryL,1), repmat(group_ind, entryL,1)];
      top10PrcStimMat = [top10PrcStimMat; newEntries];
    end
  end
end

% Produces 36 Images
top10PrcObjMat = [];
for obj_ind = 1:length(objListPlot)
  for data_ind = 1:length(dataType(1:2))
    for group_ind = 1:length(groupingType)
      % Fig 2 - 'Mean Face Rates - MUA, All Stimuli'
      figTitle = sprintf('%s %s rates, %s, All Stimuli', dataType{data_ind}, objListPlot{obj_ind}, groupingType{group_ind});
      figFilePath = fullfile(params.outputDir, figTitle);
      valInds = ((objFrameFiringRatesTable.data_ind == data_ind) + (objFrameFiringRatesTable.group_ind == group_ind)) == 2;
      stimLabel = objFrameFiringRatesTable.stim_ind(valInds);
      runInds = objFrameFiringRatesTable.run_ind(valInds);
      stimMean = objFrameFiringRatesTable.value(valInds); %stimMean is only actually the mean when it is data_ind == 1. Otherwise it is Max.
      if ~exist([figFilePath, '.fig'],'file')
        h = figure('Name', figTitle, 'NumberTitle', 'off');
        sgtitle(figTitle)
        hold on
        uniStimInds = unique(stimLabel);
        subplot(2,length(uniStimInds),[1:length(uniStimInds)])
        boxplot(stimMean,stimLabel,'Labels',uniqueStimLabels(uniStimInds), 'Symbol', 'o')
        for stim_ind = 1:length(uniqueStimLabels)
          subplot(2,length(uniStimInds),stim_ind+length(uniStimInds))
          singleStimMeans = stimMean(stimLabel == uniStimInds(stim_ind));
          histogram(singleStimMeans, 20);
          title(sprintf('%s (\x03bc  = %s)',uniqueStimLabels{uniStimInds(stim_ind)},num2str(round(mean(singleStimMeans), 2))));
        end
        linkaxes([h.Children(1:length(uniStimInds))],'xy')
        savefig(fullfile(params.outputDir, figTitle))
        close(h)
      end
      % Collect run Indices for 90th percentile
      entry = runInds(stimMean>=prctile(stimMean,90));
      entryL = length(entry);
      newEntries = [entry, repmat(obj_ind, entryL,1), repmat(data_ind, entryL,1), repmat(group_ind, entryL,1)];
      top10PrcObjMat = [top10PrcObjMat; newEntries];
    end
  end
end

% Convert to Arrays of run indices into tables
top10PrcStimTable = array2table(top10PrcStimMat);
top10PrcStimTable.Properties.VariableNames = {'run_ind', 'stim_ind', 'data_ind', 'group_ind'};

top10PrcObjTable = array2table(top10PrcObjMat);
top10PrcObjTable.Properties.VariableNames = {'run_ind', 'obj_ind', 'data_ind', 'group_ind'};

frameFiringStruct.channelUnitMat = channelUnitMat;
frameFiringStruct.top10PrcStimTable = top10PrcStimTable;
frameFiringStruct.top10PrcObjTable = top10PrcObjTable;
frameFiringStruct.objList = objListPlot;
frameFiringStruct.groupList = groupingType;
frameFiringStruct.stimList = uniqueStimLabels;
frameFiringStruct.dataList = dataType(1:2);

end

function  spikeDataBank = noveltyAnalysis(spikeDataBank, meanPSTHStruct, frameFiringStruct)
% Function seeks to analyze whether most active PSTHes are enriched from
% novel runs.
% Inputs:
% - spikeDataBank with each field containing daysSinceLastRec, daysSinceLastPres, and stimPresCount.
% - frameFiringStruct containing channelUnitMat matrix, where each row is a run index, a channel count, and a unit count.
% - 



disp('stimNov')

% Relies on neither broadLabel nor TopStim use in meanPSTH.

% for every broadLabel
  % for every group
    % for every stim
      
    % end
  % end
% end
end