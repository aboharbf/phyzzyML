function [analysisOutFilename] = runBatchAnalysis(inputs)
%%Unpack Inputs
analysisLog = struct();
load(inputs{1})   % Non spike variables, including path to spikes.
spikeDataBank = saveSpikeDataBank([], [], 'load', outputDir); %Spike variables

%Overwrite switches with what is currently in file
load(fullfile(outputDir, 'batchAnalysisParams.mat'));

%% Analyses
runList = fields(spikeDataBank);

if ~isfield(spikeDataBank.(runList{end}), 'stimPresCount')
  spikeDataBank = stimulusStatistics(spikeDataBank);
  %Save modified struct.
  saveEnv()
end

if plotSwitch.stimPresCount
  disp('plot stimPresCount')
  %Plot as an image the 'daysSinceLastPres' matrix, stimuli on Y, date on
  %X.will likely require a figure callback for making Y axis labels
  %legible.
  %At the top of the plot, I will have a single vector with 'days since
  %last recording' to highlight days after long breaks.
end

if 1%~exist('unitCounts','var')
  [trueCellInd, trueCellRun, unitCounts] = trueCellCount(cellCountParams.batchRunxls, cellCountParams.recordingLogxls);
end

% Remove repeated Runs
if ~calcSwitch.excludeRepeats && isfield(analysisLog, 'repeatsExcluded')
  error('Repeats already excluded in this spikeDataBank, delete and restart or change parameters')
elseif calcSwitch.excludeRepeats && ~isfield(analysisLog, 'repeatsExcluded')
  % Exclude repeated recordings at the same site.
  for run_ind = 1:length(runList)
    sessionName = extractBetween(runList{run_ind}, 2, length(runList{run_ind}));
    validInd = trueCellInd(strcmp(sessionName,trueCellRun));
    if sum(validInd) == 0
      % Remove entire field if all channels are repeated recordings.
      spikeDataBank = rmfield(spikeDataBank,(runList{run_ind}));
    else
      for event_ind = 1:length(spikeDataBank.(runList{run_ind}).spikesByEvent)
        % Remove individual channel info where one of the channels is
        % recording new units.
        spikeDataBank.(runList{run_ind}).spikesByEvent{event_ind} = spikeDataBank.(runList{run_ind}).spikesByEvent{event_ind}(validInd);
      end
    end
  end
  %Save modified struct.
  analysisLog.repeatsExcluded = 1;
  saveEnv() 
end

%% Combine PSTH across all runs for a particular stimulus.
%This will crash if the PSTHs aren't the same length.
if plotSwitch.meanPSTH && ~exist('meanPSTHStruct','var')
  [stimPSTH, meanPSTHStruct] = meanPSTH(spikeDataBank, meanPSTHParams);
  saveEnv()
end

%% Gather information on frame rates
if plotSwitch.frameFiringRates && ~exist('frameFiringStruct','var')
  [spikeDataBank, frameFiringStruct] = frameFiringRates(spikeDataBank, frameFiringParams);
  saveEnv()
end

%% Check whether the novelty of the runs
if plotSwitch.novelty
  assert(logical(exist('meanPSTHStruct','var')), 'Must run w/ meanPSTH enabled for novelty analysis');
  spikeDataBank = noveltyAnalysis(spikeDataBank, stimPSTH, meanPSTHStruct,[], noveltyParams);
end

%% Perform sliding window ANOVA and Omega calculations
if plotSwitch.slidingWindowANOVA % && ~isfield(spikeDataBank, [Some new field generated by function])
  spikeDataBank = slidingWindowANOVA(spikeDataBank, slidingANOVAParams);
  saveEnv()
end

end

%% Functions

function spikeDataBank = stimulusStatistics(spikeDataBank)
% Stimuli Presentation count and 'Novelty' Related Information.
%Code below creates a single large vector of stimuli used, and uses this to
%create individual vectors containing which viewing of the stimulus this
%represent (i.e. 'this run represents the 10th viewing of X.avi'). It also
%appends a dateTime vector to each structure related to how long since the
%last recording day.

runList = fields(spikeDataBank);

%extract the eventIDs field, generate a cell array of unique stimuli
allStimuliVec = struct2cell(structfun(@(x) x.eventIDs, spikeDataBank,'UniformOutput', 0));
allStimuliVec = unique(vertcat(allStimuliVec{:}));

%Produce matrix (N stim * M runs) which gives 0 for non present stim, count of stim presentation otherwise.
stimLogicalArray = zeros(length(allStimuliVec),length(runList));
for run_ind = 1:length(runList)
  stimLogicalArray(:,run_ind) = ismember(allStimuliVec,spikeDataBank.(runList{run_ind}).eventIDs);
end
csStimLogicalArray = cumsum(stimLogicalArray,2);
csStimLogicalArray(~stimLogicalArray) = 0;

% When was a stimulus first seen? Index of runList where first presentation took place.
firstStimPresInd = zeros(length(allStimuliVec),1);
for stim_ind = 1:length(allStimuliVec)
  firstStimPresInd(stim_ind) = find(stimLogicalArray(stim_ind,:),1,'first');
end

% Append a dateTime to each field with the time in days since the last
% recording. Add the relevant slice of the larger csStimLogicalArray.
for run_ind = 1:length(runList)
  spikeDataBank.(runList{run_ind}).stimPresArray = csStimLogicalArray(:,run_ind);
  spikeDataBank.(runList{run_ind}).dateTime = datetime(extractBetween(spikeDataBank.(runList{run_ind}).dateSubject,1,8),'InputFormat','yyyyMMdd');     %Generate 'daysSinceLastRec' for each field.
end

% find unique recording dates, and the distance between them. Add these
% to the spikeDataBank
allDateTimeVec = struct2cell(structfun(@(x) x.dateTime, spikeDataBank,'UniformOutput', 0));
allDateTimeVec = [allDateTimeVec{:}]';
uniqueDateTimeVec = unique(allDateTimeVec);
daysSinceLastRec = [1000; days(diff(uniqueDateTimeVec))];
for run_ind = 1:length(runList)
  spikeDataBank.(runList{run_ind}).daysSinceLastRec = daysSinceLastRec(spikeDataBank.(runList{run_ind}).dateTime == uniqueDateTimeVec);
end

% use the dateTime and stimulus presentation matrix to find out how long
% in days takes place before a particular showing of a stimulus.
daysSinceLastPres = zeros(size(stimLogicalArray));
for stim_ind = 1:size(stimLogicalArray,1)
  presentationInd = logical(stimLogicalArray(stim_ind,:)); %When was the stim shown
  daysSinceLastPres(stim_ind,presentationInd) = [1000; days(diff(allDateTimeVec(presentationInd)))]; %Duration between those dates in days
end

%Return days since last presentation and the stimulus presentation count to spikeDataBank, arranged in way that matches stim table.
for run_ind = 1:size(stimLogicalArray,2)
  [~, big2SmallInd] = ismember(spikeDataBank.(runList{run_ind}).eventIDs,allStimuliVec);
  spikeDataBank.(runList{run_ind}).daysSinceLastPres = daysSinceLastPres(big2SmallInd,run_ind);
  spikeDataBank.(runList{run_ind}).stimPresCount = csStimLogicalArray(big2SmallInd,run_ind);
end

end

function [stimPSTH, meanPSTHStruct] = meanPSTH(spikeDataBank, params)
% Function which combines stimulus presentations across all runs in the spikeDataBank.
% Inputs include spikeDataBank and list of parameters.

if ~isfile(fullfile(params.outputDir, params.tmpFileName))
  if ~exist(params.outputDir, 'dir')
    mkdir(params.outputDir)
  end
  
  % Rebuild variables
  % extract the eventIDs field, generate a cell array of unique stimuli
  allStimuliVec = struct2cell(structfun(@(x) x.eventIDs, spikeDataBank,'UniformOutput', 0));
  allStimuliVec = unique(vertcat(allStimuliVec{:}));
  
  % Generate grid for indexing into individual runs and extracting relevant
  % PSTHes.
  runList = fields(spikeDataBank);
  small2BigInd = zeros(length(allStimuliVec), length(runList));
  for run_ind = 1:length(runList)
    [~, small2BigInd(:,run_ind)] = ismember(allStimuliVec, spikeDataBank.(runList{run_ind}).eventIDs);
  end
  
  [plotMat, briefStimList, params] = plotIndex(allStimuliVec, params);
  meanPSTHStruct.briefStimList = briefStimList;
  
  if params.normalize
    normTag = ' - normalized';
  else
    normTag = '';
  end
  
  % Step 1 - Concatonate PSTHs - iterate across stimuli, grab PSTHes from each run, store
  groupingType = {'Unsorted', 'Units', 'MUA'};
  dataType = {'PSTH', 'PSTH Err', 'presCount','daysSinceLastPres','daysSinceLastRec', 'Run Ind'};
  
  meanPSTHStruct = struct();
  meanPSTHStruct.IndStructs{1} = allStimuliVec;
  meanPSTHStruct.IndStructs{2} = groupingType;
  meanPSTHStruct.IndStructs{3} = dataType;
  %stimPSTH{stim,grouping,dataType}
  stimPSTH = cell([length(allStimuliVec), length(groupingType), length(dataType)]);
  
  totalPopCount = 0;
  maxAct = [];
  
  for stim_ind = 1:length(allStimuliVec)
    % Find the runs where the stimulus was present, generate a list of them.
    stimRunIndex = small2BigInd(stim_ind,:);
    psthStimIndex = nonzeros(stimRunIndex);
    psthRunIndex = find(stimRunIndex);
    subRunList = runList(psthRunIndex);
    
    % For all runs containing a particular stimuli, retrieve relevant activity vector in each.
    for subRun_ind = 1:length(subRunList)
      tmpRunStruct = spikeDataBank.(subRunList{subRun_ind});
      for chan_ind = 1:length(tmpRunStruct.psthByImage)
        for unit_ind = 1:length(tmpRunStruct.psthByImage{chan_ind})
          % Retrieve correct PSTH from run
          unitActivity = tmpRunStruct.psthByImage{chan_ind}{unit_ind}(psthStimIndex(subRun_ind),:);
          unitErr = tmpRunStruct.psthErrByImage{chan_ind}{unit_ind}(psthStimIndex(subRun_ind),:);
          presCount = tmpRunStruct.stimPresCount(psthStimIndex(subRun_ind));
          daysSinceLastPres = tmpRunStruct.daysSinceLastPres(psthStimIndex(subRun_ind));
          daysSinceLastRec = tmpRunStruct.daysSinceLastRec;
          if sum(unitActivity) == 0 % This will get rid of unsorted unit activity which is 0 (all sorted).
            continue
          end
          % If desired, Z score PSTHs here based on fixation period activity.
          if params.normalize
            tmp = tmpRunStruct.psthByImage{chan_ind}{unit_ind}(:,1:abs(tmpRunStruct.start));
            fixMean = mean(mean(tmp)); %Find activity during fixation across all stim.
            fixMean = max(fixMean, 1);
            if params.normalize == 1
              unitActivity = ((unitActivity - fixMean)/fixMean) * 100;
              unitErr = ((unitErr - fixMean)/fixMean) * 100;
            elseif params.normalize == 2
              fixSD = std(reshape(tmp,[size(tmp,1)*size(tmp,2), 1]));
              unitActivity = ((unitActivity - fixMean)/fixSD);
              unitErr = ((unitErr - fixMean)/fixSD);
            end
          end
          if max(unitActivity) > 1e3
            maxAct = [maxAct; unitActivity];
            fprintf('Stim Ind %d, Max Val %s, Fix mean %s \n', stim_ind, num2str(max(unitActivity)), num2str(fixMean));
            if max(unitActivity) > 4000
              disp('');
            end
            %fprintf('Stim Ind %d, Max Val %s \n', stim_ind, num2str(max(unitActivity)));
            totalPopCount = totalPopCount + 1;
          end
          % Store the generated values into a dataArray
          dataArray = cell(length(dataType),1); % Structure to store and iterate across.
          dataArray{1} = unitActivity;
          dataArray{2} = unitErr;
          dataArray{3} = presCount;
          dataArray{4} = daysSinceLastPres;
          dataArray{5} = daysSinceLastRec;
          dataArray{6} = psthRunIndex(subRun_ind);
          % Concatonate to the correct Matrix (index matching phyzzy convention)
          if unit_ind == 1 % Unsorted
            groupInd = 1;
          elseif unit_ind == length(tmpRunStruct.psthByImage{chan_ind}) % MUA
            groupInd = 3;
          else % Unit
            groupInd = 2;
          end
          for data_ind = 1:length(dataArray)
            stimPSTH{stim_ind,groupInd,data_ind} = [stimPSTH{stim_ind,groupInd,data_ind}; dataArray{data_ind}];
          end
        end
      end
    end
  end
 
  % Step 2 - Plot - use indicies to retrieve data from larger stimPSTH
  % matrix.
  
  % Generate needed indicies and structures for plotting.
  allStimuliNames = cellfun(@(x) extractBetween(x, 1, length(x)-4), allStimuliVec);
  stimPresMat = cellfun(@(x) size(x,1),stimPSTH(:,:,end));
  meanPSTHStruct.stimPresMat = stimPresMat;
  broadLabelInd = logical(plotMat);
  plotInd = true(length(params.plotLabels),1);
  
  for broad_ind = 1:length(params.plotLabels)
    % Extract relevant slices of larger matricies
    sliceStimPSTH = stimPSTH(broadLabelInd(:,broad_ind),:,1:length(dataType)-4);
    sliceStimLabels = briefStimList(broadLabelInd(:,broad_ind));
    sliceStimPresMat = stimPresMat(broadLabelInd(:,broad_ind),:);
    
    % Initialize internal variables
    topStimRun = 1; %Avoids redoing process of removing low rep stim.
    
    % If you only want stim above a certain count, remove here.
    if params.plotTopStim && topStimRun
      keepInd = sliceStimPresMat(:,2) >= params.topStimPresThreshold;
      if sum(keepInd) == 0
        plotInd(broad_ind) = 0;
        continue
      else
        sliceStimPSTH = sliceStimPSTH(keepInd,:,:);
        sliceStimLabels = sliceStimLabels(keepInd,:);
        sliceStimPresMat = sliceStimPresMat(keepInd,:);
      end
    end

    % Generate a matrix of the meanPSTHes, with the last row being total
    % means. Add this to the counts as well.
    meanPSTH = cellfun(@(x) mean(x),sliceStimPSTH,'UniformOutput',0);
    catMeanMat = cell(1,size(sliceStimPSTH,2),size(sliceStimPSTH,3));
    catErrMat = cell(1,size(sliceStimPSTH,2),size(sliceStimPSTH,3));
    for group_ind = 1:length(groupingType)
      for data_ind = 1:length(dataType)-4
        tmp = vertcat(sliceStimPSTH{:,group_ind,data_ind});
        catMeanMat{1,group_ind,data_ind} = mean(tmp,1);
        catErrMat{1,group_ind,data_ind} = std(tmp)/sqrt(size(tmp,1));
      end
    end
    meanPSTH = cat(1, meanPSTH, catMeanMat);
    
    sliceStimPresMat = [sliceStimPresMat; sum(sliceStimPresMat, 1)];
    if iscell(params.plotLabels{broad_ind})
      params.plotLabels{broad_ind} = strjoin(params.plotLabels{broad_ind});
    end
    sliceStimLabels = [sliceStimLabels; params.plotLabels{broad_ind}];

    for group_ind = 1:length(groupingType)
      % Prepare labels
      stimLabels = cell(length(sliceStimLabels),1);
      for stim_ind = 1:length(stimLabels)
        stimLabels{stim_ind} = [sliceStimLabels{stim_ind} ',n = ' num2str(sliceStimPresMat(stim_ind,group_ind))];
      end
      
      for data_ind = 1:length(dataType)-4
        % Extract correct data
        plotData = vertcat(meanPSTH{:,group_ind,data_ind});
        
        % If Sorting data, do so here.
        if params.sortPresCount
          [~, newOrder] = sort(sliceStimPresMat(:,group_ind));
          plotLabels = stimLabels(newOrder);
          plotData = plotData(newOrder, :);
        else
          plotLabels = stimLabels;
        end
               
        psthTitle = sprintf('All %s Stimuli - Mean %s%s, %s', params.plotLabels{broad_ind}, dataType{data_ind}, normTag, groupingType{group_ind});
        % Plot the Activity
        h = figure('NumberTitle', 'off', 'Name', psthTitle);
        psthAxes = plotPSTH(plotData, axes(), params, 'color', psthTitle, plotLabels);
        title(psthTitle)
        grandMeanAxes = axes('YAxisLocation','right','Color', 'none','xtick',[],'xticklabel',[],'xlim',[0 size(plotData,2)]);%,'ytick',[],'yticklabel',[]);
        hold on
        lineprops.col{1} = 'k';
        mseb(1:size(plotData,2), plotData(end,:), catErrMat{end,group_ind,2}, lineprops,1);
        linkprop([psthAxes, grandMeanAxes],{'Position'});
        if params.normalize == 1
          h.Children(2).Label.String = 'Signal Change relative to Baseline (%)';
        elseif params.normalize == 2
          h.Children(2).Label.String = 'Z scored relative to fixation (%)';
        end       
        savefig(h, fullfile(params.outputDir, psthTitle));
        close(h);
      end
    end
  end
  
  % save intermediate structure to allow for plot troubleshooting.
  save(fullfile(params.outputDir, params.tmpFileName), 'stimPSTH', 'stimPresMat','allStimuliNames','groupingType','plotMat','meanPSTHStruct','normTag')
  
else
  
  % Load previously generated 
  disp('Loading tmp file')
  load(fullfile(params.outputDir, params.tmpFileName))
  
end

% Plot all Stimuli means in the same plot. 
for group_ind = 1:size(stimPSTH,2)    
  stimCounts = stimPresMat(:,group_ind);
  allStimuliLabel = cell(length(allStimuliNames),1);
  for stim_ind = 1:length(allStimuliNames)
    allStimuliLabel{stim_ind} = [allStimuliNames{stim_ind} ',n = ' num2str(stimCounts(stim_ind))];
  end
  groupData = stimPSTH(:, group_ind, 1);
  groupData = cellfun(@(x) mean(x, 1), groupData, 'UniformOutput',0);
  plotData = vertcat(groupData{:});
  
  if params.sortPresCount
    [~, newOrder] = sort(stimCounts);
    allStimuliLabel = allStimuliLabel(newOrder);
    plotData = plotData(newOrder, :);
  end  
  
  catPSTHTitle = sprintf('%s Mean PSTH - All Stimuli, %s', groupingType{group_ind}, normTag);
  h = figure('NumberTitle', 'off', 'Name', catPSTHTitle);
  catPSTHAxes = plotPSTH(plotData, axes(), params, 'color', catPSTHTitle, allStimuliLabel);
  title(catPSTHTitle);
  savefig(h, fullfile(params.outputDir, catPSTHTitle));
  close(h)
  clear allStimuliLabel
end

% for each Plot Cross Catagory comparisons as line graphs w/ Error bars.
catCount = 10;
singleCatPlotMat = plotMat(:,1:catCount);
singleCatplotLabels = params.plotLabels(1:catCount);
tmp = distinguishable_colors(catCount);
plotColors = cell(catCount,1);
for col_i = 1:catCount
  plotColors{col_i} = tmp(col_i,:);
end

for group_ind = 1:size(stimPSTH,2)
  catPSTHTitle = sprintf('%s Mean PSTH %s', groupingType{group_ind}, normTag);
  h = figure('NumberTitle', 'off', 'Name', catPSTHTitle);
  hold on
  % Generate line plots w/ error bars.
  lineProps.width = 1;
  lineProps.col = plotColors;
  lineProps.patch.FaceAlpha = '0.5';
  
  [groupData, groupErr] = deal(cell(size(singleCatPlotMat,2),1));
  for cat_ind = 1:size(singleCatPlotMat,2)
    tmp = vertcat(stimPSTH{logical(singleCatPlotMat(:,cat_ind)), group_ind});
    groupData{cat_ind} = mean(tmp,1);
    groupErr{cat_ind} = std(tmp)/sqrt(size(tmp,1));
  end
  
  groupData = vertcat(groupData{:});
  
  if params.fixAlign
    groupMean = mean(mean(groupData(:,500:800)));
    for g_ind = 1:size(groupData,1)
      groupData(g_ind,:) = groupData(g_ind,:) - mean(groupData(g_ind,500:800)) + groupMean;
    end
  end
  
  mseb(-800:(size(groupData,2)-801),groupData, vertcat(groupErr{:}), lineProps);
  xlim([-800 (size(groupData,2)-801)])
  legend(singleCatplotLabels, 'AutoUpdate','off');
  line([0 0], ylim(), 'Linewidth',3,'color','k');
  line([2800 2800], ylim(), 'Linewidth',3,'color','k');
  title(catPSTHTitle);
  savefig(h, fullfile(params.outputDir, catPSTHTitle));
  close(h)
end

% Code below generates indicies for specific group designations not already
% defined in stimParamFile.
crossCatPlotMat = plotMat(:,catCount+1:end);
socialInd = logical(crossCatPlotMat(:,1));
agentInd = logical(crossCatPlotMat(:,4));
headTurnInd = false(size(plotMat,1),1);
headTurnInd(logical(plotMat(:,1))) = true; % Chasing
headTurnInd(logical(plotMat(:,2))) = true; % Fighting
headTurnInd([72,73, 76]) = true;  % Idle w/ Head turning
headTurnInd([77, 82:85]) = true;  % Mounting
agentNHInd = agentInd;            % Agent videos
agentNHInd(headTurnInd) = false;  % Agent videos without head turning.

figIncInd = {agentInd, socialInd, headTurnInd};
figExcInd = {~agentInd, ~socialInd, agentNHInd};
figTitInd = {'Agent vs Non Agent','Soc v Non Soc','Agents Head Turning v Agents Non Head Turning'};
figLegends = {{'Agents','Non-Agent'},{'Social','Non Social'},{'Agents Head Turning','Agents Not Head Turning'}};

for fig_ind = 1:length(figIncInd)
  line1Array = stimPSTH(figIncInd{fig_ind},:,1);
  line2Array = stimPSTH(figExcInd{fig_ind},:,1);
  for group_ind = 1:size(line1Array,2)
    % Generate Data
    line1Data = vertcat(line1Array{:,group_ind});
    line2Data = vertcat(line2Array{:,group_ind});
    lineMean = [mean(line1Data, 1); mean(line2Data, 1)];
    lineErr = [std(line1Data)/sqrt(size(line1Data,1)); std(line2Data)/sqrt(size(line2Data,1))];
    
    if params.fixAlign
      fixMean = mean(mean(lineMean(:,500:800),1));
      for line_i = 1:size(lineMean,1)
        lineMean(line_i,:) = lineMean(line_i,:) - mean(lineMean(line_i,500:800)) + fixMean;
      end
    end
    
    % Prepare figure
    plotTitle = sprintf('%s - %s, %s', figTitInd{fig_ind}, groupingType{group_ind}, normTag);
    h = figure('NumberTitle', 'off', 'Name', plotTitle);
    title(plotTitle)
    mseb((-800:size(lineMean,2)-801),lineMean, lineErr, []);
    legend(figLegends{fig_ind}, 'AutoUpdate','off')
    xlim([-800 (length(lineMean)-801)])
    line([0 0], ylim(), 'Linewidth',3,'color','k');
    line([2800 2800], ylim(), 'Linewidth',3,'color','k');
    savefig(h, fullfile(params.outputDir, plotTitle));
    close(h)
  end
end

% Make a PSTH of each stimulus across all its repetitions.
runList = fields(spikeDataBank);
for stim_i = 1:length(stimPSTH)
  figTitle = sprintf('%s - all PSTHs, %s', allStimuliNames{stim_i}, normTag);
  h = figure('NumberTitle', 'off', 'Name', figTitle,'units','normalized','outerposition',[0 0 1 1]);
  sgtitle(figTitle)
  for group_i = 1:size(stimPSTH,2)
    subplot(1,3,group_i)
    imagesc(stimPSTH{stim_i,group_i,1})
    title(groupingType{group_i})
    colorbar()
    line([800 800], ylim(), 'Linewidth',3,'color','k');
    line([3600 3600], ylim(), 'Linewidth',3,'color','k');
    yticks(1:size(stimPSTH{stim_i,group_i,1},1))
    yticklabels(runList(stimPSTH{stim_i,group_i,6}));
  end
  savefig(h, fullfile(params.outputDir, figTitle));
  close(h)
end


end

function spikeDataBank = slidingWindowANOVA(spikeDataBank,params)
% Perform sliding scale ANOVA, calculate Omega at each bin.

if ~exist(params.outputDir, 'dir')
  mkdir(params.outputDir)
end

% Generate variables needed
runList = fields(spikeDataBank);
binSize = params.binSize;
binStep = params.binStep;
target = params.target;
Omega = params.Omega;
stimParamFile = params.stimParamFile;
nestStrCmp = @(x, y) any(strcmp(x, y));

% Step 1 - for each bin (epoch), calculate the rates and counts. save them
% into a larger epochRates structure, which can be stored in the folder for
% this function for subsequent runs. 

if ~exist(fullfile(params.outputDir, 'epochRates.mat'), 'file')
  epochRates = cell(length(runList),1);
  catagoryInd = cell(length(runList),1);
  % Step 1 - generate bin times and spike rates, and proper memberships to groups.
  for run_ind = 1:length(runList)
    runStruct = spikeDataBank.(runList{run_ind});
    starts = (runStruct.start:binStep:(runStruct.end - binSize))';
    ends = (runStruct.start+binSize:binStep:(runStruct.end))';
    spikeDataBank.(runList{run_ind}).epochs = [starts,ends];
    epochRates{run_ind} = cell(length(starts),1);
    for bin_ind = 1:length(starts)
      [epochRates{run_ind}{bin_ind}, ~, ~] = spikeCounter(spikeDataBank.(runList{run_ind}).spikesByEvent, starts(bin_ind), ends(bin_ind));
    end
    for group_ind = 1:length(target)
      catagoryInd{run_ind}(:,group_ind) = cell2mat(cellfun(nestStrCmp, runStruct.eventCategories, repmat(target(group_ind), [length(runStruct.eventCategories),1]), 'UniformOutput',0));
    end
  end
  save(fullfile(params.outputDir, 'epochRates'), 'epochRates', 'catagoryInd');
else
  load(fullfile(params.outputDir, 'epochRates'), 'epochRates', 'catagoryInd');
  assert(length(epochRates) == length(runList), 'epochRates length does not match runList length');
  fprintf('Sliding windows rates already calculated, continuing... \n');
end

% Step 2 - Perform ANOVA, Omega calculation across bins, and store values.
% Save the output in the function folder for later retrieval. 

statsType = {'pVec', 'omegaVec', 'meanNullVec', 'meanErrVec' 'nullOmegaVec', 'maxNullOmegaVec'};

if 1%~exist(fullfile(params.outputDir, 'allStatsArray.mat'), 'file')
  chanUnitStruct = structfun(@(x) x.psthByImage, spikeDataBank,'UniformOutput',0);
  chanUnitStruct = struct2cell(chanUnitStruct);
  allStatsArray = initNestedCellArray(chanUnitStruct, 'zeros', [length(epochRates{1}), length(target), length(statsType)], 3);
  clear chanUnitStruct;
  scrambleCount = params.scrambleCount;
  
  tic
  if 0% license('test','Distrib_Computing_Toolbox')
    epochRatesPar = parallel.pool.Constant(epochRates);
    catagoryIndPar =  parallel.pool.Constant(catagoryInd);
    parfor run_ind = 1:length(runList)
      % Initialize relevant Structures
      if length(unique(catagoryIndPar.Value{run_ind})) > 1 %Only run tests where you have members in each group.
        binCount = length(epochRatesPar.Value{run_ind});
        for chan_ind = 1:length(epochRatesPar.Value{run_ind}{1})
          for unit_ind = 1:length(epochRatesPar.Value{run_ind}{1}{chan_ind})
            for bin_ind = 1:binCount
              unitResponsePerEvent = epochRatesPar.Value{run_ind}{bin_ind}{chan_ind}{unit_ind};
              catagortyIndSlice = catagoryIndPar.Value{run_ind};
              %unitData{event}.rates = trial*1
              for target_ind = 1:length(target)
                if length(unique(catagortyIndSlice(:,target_ind))) == 1
                  break % If there is only 1 label type, there is no comparison to be made.
                end
                [trialSpikes, trialLabels]  = deal([]);
                % grab the relevant events
                targetInd = catagortyIndSlice(:,target_ind);
                targetSpikes = unitResponsePerEvent(targetInd);
                otherSpikes = unitResponsePerEvent(~targetInd);
                % Initialize relevant vecotrs
                spikeGroups = {targetSpikes otherSpikes};
                spikeGroupLabels ={(target{target_ind}) (['non-' target{target_ind}])};
                % Cluster and reshape the arrays properly
                for group_i = 1:length(spikeGroups)
                  tmp = spikeGroups{group_i};
                  tmp = [tmp{:}];
                  dataVec = vertcat(tmp.rates);
                  labelVec = repmat(spikeGroupLabels(group_i), length(dataVec),1);
                  trialSpikes = vertcat(trialSpikes,dataVec);
                  trialLabels = vertcat(trialLabels, labelVec);
                end
                % Check for social v non-social
                % 3rd ind in 3D mat statsType = {'pVec', 'omegaVec', 'meanNullVec', 'meanErrVec' 'nullOmegaVec', 'maxNullOmegaVec'};
                [allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('pVec',statsType)), pStatsTable, ~] = anovan(trialSpikes,{trialLabels},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
                top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
                bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
                if isnan(top/bottom)
                  allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('omegaVec',statsType)) = 0;
                else
                  allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('omegaVec',statsType)) = top/bottom;
                end                % Perform Calculations on scrambles
                [nullPVec, nullOmegaVecSingle] = deal(zeros(1,scrambleCount));
                for rand_ind = 1:scrambleCount
                  [nullPVec(rand_ind), pStatsTable, ~] = anovan(trialSpikes,{trialLabels(randperm(length(trialLabels)))},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
                  top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
                  bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
                  nullOmegaVecSingle(rand_ind) = top/bottom;
                end
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('meanNullVec',statsType)) = mean(nullPVec);
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('meanErrVec',statsType)) = std(nullPVec)/sqrt(length(nullPVec));
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('nullOmegaVec',statsType)) = mean(nullOmegaVecSingle);
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('maxNullOmegaVec',statsType)) = max(nullOmegaVecSingle);
              end
            end
          end
        end
      else
        disp('Skipping')
      end
    end
    save(fullfile(params.outputDir, 'allStatsArray'), 'allStatsArray');
    fprintf('Done in %d hours \n', toc/3600)
  else

    for run_ind = 1%:length(runList)
      % Initialize relevant Structures
      if length(unique(catagoryInd{run_ind})) > 1 %Only run tests where you have members in each group.
        chanCount = length(epochRates{run_ind}{1});
        binCount = length(epochRates{run_ind});
        for chan_ind = 1:chanCount
          for unit_ind = 1:length(epochRates{run_ind}{1}{chan_ind})
            for bin_ind = 1:binCount
              unitResponsePerEvent = epochRates{run_ind}{bin_ind}{chan_ind}{unit_ind};
              catagortyIndSlice = catagoryInd{run_ind};
              %unitData{event}.rates = trial*1
              for target_ind = 1:length(target)
                if length(unique(catagortyIndSlice(:,target_ind))) == 1
                  break % If there is only 1 label type, there is no comparison to be made.
                end
                [trialSpikes, trialLabels]  = deal([]);
                % grab the relevant events
                targetInd = catagortyIndSlice(:,target_ind);
                targetSpikes = unitResponsePerEvent(targetInd);
                otherSpikes = unitResponsePerEvent(~targetInd);
                % Initialize relevant vecotrs
                spikeGroups = {targetSpikes otherSpikes};
                spikeGroupLabels ={(target{target_ind}) (['non-' target{target_ind}])};
                % Cluster and reshape the arrays properly
                for group_i = 1:length(spikeGroups)
                  tmp = spikeGroups{group_i};
                  tmp = [tmp{:}];
                  dataVec = vertcat(tmp.rates);
                  labelVec = repmat(spikeGroupLabels(group_i), length(dataVec),1);
                  trialSpikes = vertcat(trialSpikes,dataVec);
                  trialLabels = vertcat(trialLabels, labelVec);
                end
                % Check for social v non-social
                % 3rd ind in 3D mat statsType = {'pVec', 'omegaVec', 'meanNullVec', 'meanErrVec' 'nullOmegaVec', 'maxNullOmegaVec'};
                [allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('pVec',statsType)), pStatsTable, ~] = anovan(trialSpikes,{trialLabels},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
                top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
                bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
                if isnan(top/bottom)
                  allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('omegaVec',statsType)) = 0;
                else
                  allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('omegaVec',statsType)) = top/bottom;
                end
                % Perform Calculations on scrambles
                [nullPVec, nullOmegaVecSingle] = deal(zeros(1,scrambleCount));
                for rand_ind = 1:scrambleCount
                  [nullPVec(rand_ind), pStatsTable, ~] = anovan(trialSpikes,{trialLabels(randperm(length(trialLabels)))},'model','interaction','varnames',{'SvNS'}, 'alpha', 0.05,'display','off');
                  top = pStatsTable{2,3} * (pStatsTable{2,5} - pStatsTable{3,5});
                  bottom = (pStatsTable{2,3}*pStatsTable{2,5})+(pStatsTable{4,3}-pStatsTable{2,3})*pStatsTable{3,5};
                  nullOmegaVecSingle(rand_ind) = top/bottom;
                end
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('meanNullVec',statsType)) = mean(nullPVec);
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('meanErrVec',statsType)) = std(nullPVec)/sqrt(length(nullPVec));
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('nullOmegaVec',statsType)) = mean(nullOmegaVecSingle);
                allStatsArray{run_ind}{chan_ind}{unit_ind}(bin_ind,target_ind, strcmp('maxNullOmegaVec',statsType)) = max(nullOmegaVecSingle);
              end
            end
          end
        end
      else
        disp('Skipping')
      end
    end
    save(fullfile(params.outputDir, 'allStatsArray'), 'allStatsArray');
    fprintf('Done in %d hours \n', toc/3600)
  end
else
  fprintf('Loading statsArray from saved data... \n')
  load(fullfile(params.outputDir, 'allStatsArray.mat'), 'allStatsArray');
  assert(length(allStatsArray) == length(runList), 'allStatsArray length does not match runList length');
end
%
%     % Plot the results for each unit seen
%     if params.plotANOVA
%       for chan_ind = 1:length(statsArray)
%         for unit_ind = 1:length(statsArray{chan_ind})
%           if unit_ind == 1
%             ANOVAvarName = ['Ch' num2str(chan_ind) ' Unsorted - SocVsNonSoc'];
%           elseif unit_ind == length(statsArray{chan_ind})
%             ANOVAvarName = ['Ch' num2str(chan_ind) ' MUA - SocVsNonSoc'];
%           else
%             ANOVAvarName = ['Ch' num2str(chan_ind) ' U' num2str(unit_ind-1) ' - SocVsNonSoc'];
%           end
%           if ~any(any(isnan(statsArray{chan_ind}{unit_ind}(:,:,1))))
%             k = figure();
%             plot(statsArray{chan_ind}{unit_ind}(:,:,1),'linewidth',2)
%             hold on
%             xlim([0,size(statsArray{chan_ind}{unit_ind}(:,:,1),1)]);
%             ylim([0,1]);
%             plot([0,size(statsArray{chan_ind}{unit_ind}(:,:,1),1)],[0.05, 0.05],'k','linewidth',3)
%             fracSig = round(sum(statsArray{chan_ind}{unit_ind}(:,:,1) < 0.05)/length(statsArray{chan_ind}{unit_ind}(:,:,1)), 3, 'significant');
%             fragSigNull = round(sum(statsArray{chan_ind}{unit_ind}(:,:,1) < 0.4)/length(statsArray{chan_ind}{unit_ind}(:,:,1)), 3, 'significant');
%             nullLines = cell(length(target),1);
%             for null_ind = 1:length(target)
%               nullLines{null_ind} = mseb(1:length(statsArray{chan_ind}{unit_ind}(:,:,2)),statsArray{chan_ind}{unit_ind}(:,null_ind,2)', statsArray{chan_ind}{unit_ind}(:,null_ind,2)');
%               nullLines{null_ind}.patch.FaceAlpha = '0.5';
%             end
%             % Create Legend and Title
%             titleString = sprintf('Sliding Scale ANOVA - %s',ANOVAvarName);
%             title(titleString)
%             legendText = cell(length(target),1);
%             for leg_ind = 1:length(target)
%               legendText{leg_ind} = sprintf('%s (%s;%s)', target{leg_ind}, num2str(fracSig(leg_ind)),num2str(fragSigNull(leg_ind)));
%             end
%             legend(legendText);
%             % Save and close
%             savefig(k, fullfile(spikeDataBank.(runList{run_ind}).figDir,titleString))
%             close(k)
%           end
%         end
%       end
%     end
%     % Every 20 runs, save progress back to the files
%     if mod(run_ind,20) == 0 || run_ind == length(runList)
%       disp(run_ind)
%       saveSpikeDataBank(spikeDataBank, 2, 'save',params.outputDir);
%     end
% end

fprintf('ANOVA Omega Calculations finished... \n')

% Step 3 - Count Results of ANOVA across all units and count stretches of significant
% bins.
totalUnitCount = 0;
totalChannelCount = 0;
groupingType = {'Unsorted', 'Unit', 'MUA'};
% target = {'socialInteraction','agents','interaction'};, pulled from params.
dataType = {'sigBins','nullSigBins'};
statType = {'Counts', 'Sig Run Lengths',' Mean Stretch Lengths', 'Max run lengths'};
omegaStatType = {'Raw', 'Maximum values'};

ANOVAmat = zeros(length(epochRates{1}), length(target), length(groupingType), length(dataType)); % (binCount, target, group, dataType)
targetRunLens = cell(length(target), length(groupingType), length(statType));
omegaData = cell(length(target), length(groupingType), length(omegaStatType));

for run_ind = 1:length(allStatsArray)
  for chan_ind = 1:length(allStatsArray{run_ind})
    unitCount = length(allStatsArray{run_ind}{chan_ind});
    totalUnitCount = totalUnitCount + (unitCount - 2);
    totalChannelCount = totalChannelCount + 1;
    for unit_ind = 1:unitCount
      uPVec = allStatsArray{run_ind}{chan_ind}{unit_ind}(:,:,strcmp('pVec',statsType));
      if ~isempty(uPVec)
        uPVec(uPVec == 0) = nan;
        uNullVec = allStatsArray{run_ind}{chan_ind}{unit_ind}(:,:,strcmp('nullVec',statsType));
        uNullVec(uNullVec == 0) = nan;
        omegaVec = allStatsArray{run_ind}{chan_ind}{unit_ind}(:,:,strcmp('omegaVec',statsType));
        omegaVec(isnan(omegaVec)) = 0;
        % Check for significant bins
        tmpSigCount = uPVec < 0.05;
        tmpNullSigCount = uNullVec < 0.05;
        % Add to relevant structures
        if unit_ind == 1
          group_i = 1;
        elseif unit_ind == unitCount
          group_i = 3;
        else
          group_i = 2;
        end
        % Save significant bins and null bins correctly.
        ANOVAmat(:, :, group_i, 1) = ANOVAmat(:, :, group_i, 1) + tmpSigCount;
        ANOVAmat(:, :, group_i, 2) = ANOVAmat(:, :, group_i, 2) + tmpNullSigCount;
        % Keep count of consecutive bins
        for targ_i = 1:length(target)
          trace = tmpSigCount(:,targ_i);
          starts = find(diff([0; trace]) == 1);
          ends = find(diff([trace; 0]) == -1)+1;
          runLengths = ends - starts;
          targetRunLens{targ_i, group_i, 1} = [targetRunLens{targ_i, group_i, 1}; sum(trace)];
          targetRunLens{targ_i, group_i, 2} = [targetRunLens{targ_i, group_i, 2}; runLengths];
          targetRunLens{targ_i, group_i, 3} = [targetRunLens{targ_i, group_i, 3}; mean(runLengths)];
          targetRunLens{targ_i, group_i, 4} = [targetRunLens{targ_i, group_i, 4}; max(runLengths)];
          
          omegaTrace = omegaVec(:,targ_i)';
          omegaData{targ_i, group_i, 1} = [omegaData{targ_i, group_i, 1}; omegaTrace];
          omegaData{targ_i, group_i, 2} = [omegaData{targ_i, group_i, 2}; max(omegaTrace)];
          
        end
      end
    end
  end
end

% Plot Results - using values found in ANOVAmat and targetRunLens
% Fig 1 - 'Social Interactions, Run Length Stats' 4 * 3 grid, 1 subplot per
% group and stat.

for targ_i = 1:length(target)
  figTitle = sprintf('Summary Statistic for Omega/ANOVA curves - %s', target{targ_i});
  h = figure('NumberTitle', 'off', 'Name', figTitle,'units','normalized','outerposition',[0 0 1 1]);
  sgtitle(figTitle);
  for group_i = 1:length(groupingType)
    for plot_i = 1:length(statType)
      plotInd = ((group_i - 1) * length(statType)) + plot_i;
      subplot(length(groupingType), length(statType), plotInd);
      plotData = targetRunLens{targ_i, group_i, plot_i};
      histogram(plotData);
      plotTitle = sprintf('%s - %s', statType{plot_i}, groupingType{group_i});
      title(plotTitle);
    end
  end
end

% Figure 2 - the mean Omega Curve.
for targ_i = 1:length(target)
  figTitle = sprintf('Summary Statistic for Omega curves - %s', target{targ_i});
  h = figure('NumberTitle', 'off', 'Name', figTitle,'units','normalized','outerposition',[0 0 1 1]);
  sgtitle(figTitle);
  for group_i = 1:length(groupingType)
    for plot_i = 1:length(omegaStatType)
      plotInd = ((group_i - 1) * length(omegaStatType)) + plot_i;
      subplot(length(groupingType), length(omegaStatType), plotInd);
      plotData = omegaData{targ_i, group_i, plot_i};
      histogram(plotData);
      plotTitle = sprintf('%s - %s', omegaStatType{plot_i}, groupingType{group_i});
      title(plotTitle);
    end
  end
end

legendCells = cell(length(target)*2,1);
for legend_i = 1:length(target)
  legendCells{legend_i} = target{legend_i};
  legendCells{legend_i+length(target)} = ['Label scramble ' target{legend_i}];
end

figure
subplot(3,1,1)
plot(allUnitTraces,'Linewidth',3);
legend(legendCells);
ylim([0 totalUnitCount/5]);
xlim([0 length(allUnitTraces)])
title('Significant Units per Bin')
subplot(3,1,2)
plot(allMUATraces,'Linewidth',3);
legend(legendCells);
ylim([0 totalUnitCount/5]);
xlim([0 length(allUnitTraces)])
title('Significant MUA per Bin')
subplot(3,1,3)
plot(allUnsortedTraces,'Linewidth',3);
legend(legendCells);
ylim([0 totalUnitCount/5]);
xlim([0 length(allUnitTraces)])
title('Significant Unsorted per Bin')

% Fig 2 - Numbers of bins per stimuli, length of stretches
figure()
for ii = 1:length(target)
  %Plot significant bin count per unit
  subplot(length(target), 2, (ii*2)-1)
  histogram(sigBinCountTotal(:,ii),50)
  title(sprintf('Number of bins per unit (%s)',target{ii}))
  %Plot stretch duration per unit
  subplot(length(target), 2, (ii * 2))
  histogram(targetRunLengths.(target{ii}))
  title(sprintf('Length of significant bin runs per unit (%s)',target{ii}))
end

% Fig 3 - Plot Omega curves, save to Run folder.
allMaxOmegas = [];
figData.binSize = binSize; %figData required to save figure.
figData.binStep = binStep;
for run_ind = 1:length(runList)
  omegaVec = spikeDataBank.(runList{run_ind}).omegaVec;
  for chan_ind = 1:length(omegaVec)
    for unit_ind = 1:length(omegaVec{chan_ind})
      if unit_ind == 1
        ANOVAvarName = ['Ch' num2str(chan_ind) ' Unsorted'];
      elseif unit_ind == length(omegaVec{chan_ind})
        ANOVAvarName = ['Ch' num2str(chan_ind) ' MUA'];
      else
        ANOVAvarName = ['Ch' num2str(chan_ind) ' unit ' num2str(unit_ind-1)];
        allMaxOmegas = [allMaxOmegas; spikeDataBank.(runList{run_ind}).maxOmegaVec{chan_ind}{unit_ind}];
      end
      figure()
      plot(omegaVec{chan_ind}{unit_ind},'linewidth',2)
      hold on
      xlim([0,size(omegaVec{chan_ind}{unit_ind},1)]);
      ylim([0,0.2]);
      title(sprintf('Sliding Window ANOVA Omega - %s, %d ms bin', ANOVAvarName, binSize))
      legendText = cell(length(target),1);
      for leg_ind = 1:length(target)
        legendText{leg_ind} = sprintf('%s', target{leg_ind});
      end
      legend(legendText);
      starts = spikeDataBank.(runList{run_ind}).epochs(:,1);
      xticks(1:10:length(starts))
      xticklabels(starts(1:10:length(starts)));
      fileName = sprintf('Omega Curve - %s, %d ms bins, %d ms step', ANOVAvarName, binSize, binStep);
      savePath = [spikeDataBank.(runList{run_ind}).figDir filesep];
      saveFigure(savePath, fileName, figData, 1, 0, 0, runList{run_ind}, 'close')
    end
  end
end

%Distribution of peak sensitivities 
for ii = 1:size(allMaxOmegas,2)
  figure
  hist(allMaxOmegas(:,ii),20);
  title(target{ii});
end

end

function [spikeDataBank, frameFiringStruct]  = frameFiringRates(spikeDataBank,params)
% Generates means and distributions based on what is being looking at.

% Generate variables needed
runList = fields(spikeDataBank);

if ~exist(params.outputDir, 'dir')
  mkdir(params.outputDir)
end

% Step 1 - generate bin times and spike rates.
if ~isfield(spikeDataBank.(runList{end}), 'frameFiringRates')
  for run_ind = 1:length(runList)
    runStruct = spikeDataBank.(runList{run_ind});
    if length(unique(cellfun('length',runStruct.attendedObjData.frameStartInd))) == 1 % If all the videos are the same number of frames
      starts = runStruct.attendedObjData.frameStartInd{1}'+params.delay;
      ends = runStruct.attendedObjData.frameEndInd{1}'+params.delay;
      spikeDataBank.(runList{run_ind}).frameTimes = [starts,ends];
      spikeDataBank.(runList{run_ind}).frameFiringRates = cell(length(starts),1);
      frameFiringRatesTmp = cell(length(starts),1);
      for frame_ind = 1:length(starts)
        % spikeDataBank.run.framingFiringRates{epoch/bin}{channel}{unit}{stim}
        [frameFiringRatesTmp{frame_ind}, ~, ~] = spikeCounter(spikeDataBank.(runList{run_ind}).spikesByEvent, starts(frame_ind), ends(frame_ind));
      end
    else
      error('Different stimuli contain different number of frames. Implement different spikeCounting method.')
    end
    % Step 1.5 - Rearrange frameFiringRatesTmp to match attendedObjVect data {channel}{unit}{stimuli}(trials*frames)
    frameCount = length(frameFiringRatesTmp);
    trialCount = length(frameFiringRatesTmp{1}{1}{1}{1}.counts);
    frameFiringRates = initNestedCellArray(frameFiringRatesTmp{1},'zeros',[trialCount, frameCount]);
    for chan_ind = 1:length(frameFiringRatesTmp{1})
      for unit_ind = 1:length(frameFiringRatesTmp{1}{chan_ind})
        frameFiringRatesUnitTmp = initNestedCellArray(runStruct.attendedObjData.attendedObjVect, 'zeros', [size(runStruct.attendedObjData.attendedObjVect{1})],1);
        for frame_ind = 1:length(frameFiringRatesTmp)
          for stim_ind = 1:length(frameFiringRatesTmp{frame_ind}{chan_ind}{unit_ind})
            if frame_ind == 1
              frameFiringRatesUnitTmp{stim_ind} = zeros(size(runStruct.attendedObjData.attendedObjVect{stim_ind}));
            end
            if params.useRates
            frameFiringRatesUnitTmp{stim_ind}(:,frame_ind) = frameFiringRatesTmp{frame_ind}{chan_ind}{unit_ind}{stim_ind}.rates;
            else
              frameFiringRatesUnitTmp{stim_ind}(:,frame_ind) = frameFiringRatesTmp{frame_ind}{chan_ind}{unit_ind}{stim_ind}.counts;
            end
          end
        end
        frameFiringRates{chan_ind}{unit_ind} = frameFiringRatesUnitTmp;
      end
    end
    spikeDataBank.(runList{run_ind}).frameFiringRates = frameFiringRates;
    disp(run_ind)
  end
  saveSpikeDataBank(spikeDataBank, 2, 'save',fileparts(params.outputDir));
else
  fprintf('Frame firing rates already calculated., continuing... \n');
end

% Step 2 - Go through each run, sum frame counts/rates associated with the
% specific objects being attended.
objList = spikeDataBank.(runList{1}).attendedObjData.objList;
objListBroad = {'Face','Body','Hand','GazeFollow','Object','Bkg'};

if params.broadLabels
  objListPlot = objListBroad;
else
  objListPlot = objList;
end

% Step 3 - Generate vectors with data from all runs, organized as follows
% from ObjFrameFiringRates{channel}{unit}{stim}{obj}{dataType} to
% objFrameFiringRatesTotal{stim}{obj}{groupingType}{dataType}
groupingType = {'Unsorted','Units','MUA'};
dataType = {'Raw','Mean','Run Ind'};

% Pooling across runs requires vector of all stim, extract the eventIDs field, generate a cell array of unique stimuli
allStimuliVec = struct2cell(structfun(@(x) x.eventIDs, spikeDataBank,'UniformOutput', 0));
[allStimuliVec, ~, ic] = unique(vertcat(allStimuliVec{:}));
allStimuliVecCounts = accumarray(ic,1);

objFrameFiringRatesTotal = cell([length(allStimuliVec),length(groupingType), length(objListPlot), length(dataType)]);
%objFrameFiringRatesTotal{stim_ind, group_ind, obj_ind, data_ind};

channelUnitMat = [];
for run_ind = 1:length(runList)
  frameFiringRates = spikeDataBank.(runList{run_ind}).frameFiringRates;
  attendedObjVect = spikeDataBank.(runList{run_ind}).attendedObjData.attendedObjVect;
  eventIDs = spikeDataBank.(runList{run_ind}).eventIDs;
  chanCount = 0;
  unitCount = 0;
  
  % Per Stimuli Plot
  for channel_ind = 1:length(frameFiringRates)
    chanCount = chanCount + 1;
    for unit_ind = 1:length(frameFiringRates{channel_ind})
      unitCount = unitCount + 1;
      if unit_ind == 1
        groupInd = 1;  %Unsorted
      elseif unit_ind == length(frameFiringRates{channel_ind}) % MUA
        groupInd = 3;  %MUA
      else
        groupInd = 2;  %Unit
      end
      for stim_ind = 1:length(attendedObjVect)
        stimStoreInd = strcmp(spikeDataBank.(runList{run_ind}).eventIDs{stim_ind}, allStimuliVec);
        stimAttendedObj = attendedObjVect{stim_ind};
        spikeStruct = frameFiringRates{channel_ind}{unit_ind}{stim_ind};
        %ObjFrameFiringRatesStim = initNestedCellArray([length(objListPlot), length(dataType)],'zeros');
        for obj_ind = 1:length(objList)
          objRates = spikeStruct(strcmp(stimAttendedObj, objList{obj_ind}));
          
          % Identify correct object group, when using broad labels.
          if params.broadLabels
            switch find(strcmp(objList,objList{obj_ind}))
              case {1,7};         objStoreInd = 1;
              case {2,8};         objStoreInd = 2;
              case {3,4,9,10};    objStoreInd = 3;
              case {5,11};        objStoreInd = 4;
              case {6,12};        objStoreInd = 5;
              case 13;            objStoreInd = 6;
            end
          else
            objStoreInd = obj_ind;
          end
          if ~isempty(objRates)
            %ObjFrameFiringRatesStim{objStoreInd}{1} = [ObjFrameFiringRatesStim{objStoreInd}{1}; objRates];
            objFrameFiringRatesTotal{stimStoreInd, groupInd, objStoreInd, 1} = [objFrameFiringRatesTotal{stimStoreInd, groupInd, objStoreInd, 1}; objRates];
            objFrameFiringRatesTotal{stimStoreInd, groupInd, objStoreInd, 2} = [objFrameFiringRatesTotal{stimStoreInd, groupInd, objStoreInd, 2}; mean(objRates)];
            objFrameFiringRatesTotal{stimStoreInd, groupInd, objStoreInd, 3} = [objFrameFiringRatesTotal{stimStoreInd, groupInd, objStoreInd, 3}; run_ind];
          end
        end
      end
    end
  end
  % Structure is ObjFrameFiringRates{stim}{obj}{channel}{unit}{dataType}
  channelUnitMat = [channelUnitMat; [run_ind, chanCount, unitCount]];
end
disp('Finished calculating objFrameFiringRatesTotal...')

% Generate the correct labels depending on whether broad labels are used
% for objects.
% Broad Label - Swaps labels of individual stimuli for broader catagories,
% as defined in stimParamFile and the parameters.
tmp = load(params.stimParamsFilename);
for event_i = 1:length(tmp.paramArray)
  totalEventIDs{event_i} = tmp.paramArray{event_i}{1}; %per the stimParamFile spec, this is the event ID
end
totalEventIDs = totalEventIDs';
[~, paramSortVec] = ismember(allStimuliVec, totalEventIDs);
paramArray = tmp.paramArray(paramSortVec);

%Iterate across stimuli and assign new labels.
allStimuliVecBroad = cell(length(allStimuliVec),1);
for label_ind = 1:length(allStimuliVec)
  paramStimSet = paramArray{label_ind};
  allStimuliVecBroad{label_ind} = paramStimSet{ismember(paramStimSet,params.broadLabelPool)};
end
[uniqueStimLabels, ~, stimIndex] = unique(allStimuliVecBroad);

% Find out how many of each of the newly labeled stimuli there are
% uniqueStimLabelCounts = cell2mat(arrayfun(@(x)length(find(stimIndex == x)), unique(stimIndex), 'Uniform', false));

% Step 5 - Generate figures
% Produces 72 images
for stim_ind = 1:length(uniqueStimLabels)
  for group_ind = 1:length(groupingType)
    figTitle = sprintf('%s, Per Object Rates, %s - %s', uniqueStimLabels{stim_ind}, dataType{2}, groupingType{group_ind});
    figFilePath = fullfile(params.outputDir, figTitle);
    if ~exist([figFilePath, '.fig'],'file')
      % Fig 1 - 'Chasing, Per Object Rates Means - MUA'
      stimMatInd = strcmp(uniqueStimLabels(stim_ind), allStimuliVecBroad);
      stimObjData = objFrameFiringRatesTotal(stimMatInd, group_ind, :,  2);
      plotArray = cell(length(objListPlot),2);
      removeInd = false(size(stimObjData,3),1);
      for obj_ind = 1:size(stimObjData,3)
        plotArray{obj_ind,1} = vertcat(stimObjData{:,:,obj_ind});
        removeInd(obj_ind) = isempty(plotArray{obj_ind,1});
        plotArray{obj_ind,2} = objListPlot{obj_ind};
      end
      plotArray(removeInd,:) = [];
      h = figure('Name', figTitle, 'NumberTitle', 'off');
      sgtitle(figTitle)
      hold on
      uniqueObjLabels = plotArray(:,2);
      [tmpValues, tmpLabels] = deal([]);
      for obj_ind = 1:length(uniqueObjLabels)
        subplot(2,length(uniqueObjLabels),obj_ind+length(uniqueObjLabels))
        singleObjMeans = plotArray{obj_ind,1};
        histogram(singleObjMeans, 20)
        title(sprintf('%s (\x03bc  = %s)',uniqueObjLabels{obj_ind}, num2str(round(mean(singleObjMeans), 2)) ));
        tmpValues = [tmpValues; singleObjMeans];
        tmpLabels = [tmpLabels; repmat(uniqueObjLabels(obj_ind) ,[length(singleObjMeans),1])];
      end
      subplot(2,length(uniqueObjLabels),[1:length(uniqueObjLabels)])
      boxplot(tmpValues, tmpLabels, 'Symbol', 'o')
      linkaxes(h.Children(2:length(h.Children)-1),'xy')
      savefig(fullfile(params.outputDir, figTitle))
      close(h)
    end 
  end
end

% Produces 36 Images
for obj_ind = 1:length(objListPlot)
  for group_ind = 1:length(groupingType)
    % Fig 2 - 'Mean Face Rates - MUA, All Stimuli'
    figTitle = sprintf('%s %s rates, %s, All Stimuli', dataType{2}, objListPlot{obj_ind}, groupingType{group_ind});
    figFilePath = fullfile(params.outputDir, figTitle);    
    if ~exist([figFilePath, '.fig'],'file')
      % Collect relevant data for plot
      stimObjData = objFrameFiringRatesTotal(:, group_ind, obj_ind,  2);
      plotArray = cell(length(uniqueStimLabels),2);
      removeInd = false(length(uniqueStimLabels),1);
      for stim_i = 1:length(uniqueStimLabels)
        stimMatInd = strcmp(uniqueStimLabels(stim_i), allStimuliVecBroad);
        plotArray{stim_i,1} = vertcat(stimObjData{stimMatInd});
        removeInd(stim_i) = isempty(plotArray{stim_i,1});
        plotArray{stim_i,2} = uniqueStimLabels{stim_i};
      end
      plotArray(removeInd,:) = [];
      
      if ~isempty(plotArray)
        % Set up grid of subplots correctly
        h = figure('Name', figTitle, 'NumberTitle', 'off', 'units','normalized','outerposition',[0 0 1 1]);
        sgtitle(figTitle)
        hold on
        stim2Plot = size(plotArray,1);
        [tmpValues, tmpLabels] = deal([]);
        for stim_ind = 1:stim2Plot
          subplot(2,stim2Plot,stim_ind+stim2Plot)
          stimObjMeans = plotArray{stim_ind,1};
          histogram(stimObjMeans, 20);
          title(sprintf('%s (\x03bc  = %s)',plotArray{stim_ind,2},num2str(round(mean(stimObjMeans), 2))));
          tmpValues = [tmpValues; stimObjMeans];
          tmpLabels = [tmpLabels; repmat(plotArray(stim_ind,2) ,[length(stimObjMeans),1])];
        end
        subplot(2,stim2Plot,1:stim2Plot)
        boxplot(tmpValues, tmpLabels, 'Symbol', 'o')
        linkaxes(h.Children(2:length(h.Children)-1),'xy')
        savefig(fullfile(params.outputDir, figTitle))
        close(h)
      end
    end
  end
end

% Convert to Arrays of run indices into tables
frameFiringStruct.channelUnitMat = channelUnitMat;
frameFiringStruct.objList = objListPlot;
frameFiringStruct.groupList = groupingType;
frameFiringStruct.stimList = uniqueStimLabels;
frameFiringStruct.dataList = dataType(1:2);

end

function  [spikeDataBank, stimPSTH] = noveltyAnalysis(spikeDataBank, stimPSTH, meanPSTHStruct, frameFiringStruct, params)
% Function seeks to analyze whether most active PSTHes are enriched from
% novel runs.
% Inputs:
% - spikeDataBank
% - stimPSTH - the output of meanPSTH, which has indexing information in
% meanPSTHStruct.IndStructs.

if ~exist(params.outputDir, 'dir')
  mkdir(params.outputDir)
end

stimuliFileNames = meanPSTHStruct.IndStructs{1};
groupTypes = meanPSTHStruct.IndStructs{2};
dataTypes = meanPSTHStruct.IndStructs{3};
stimuliNames = cellfun(@(x) extractBetween(x, 1, length(x)-4), stimuliFileNames);
stimPresMat = meanPSTHStruct.stimPresMat;
epochs = {[300 800], [860 3380], [3680 4100]};
epochNames = {'Fixation','Stim Presentation','Reward'};
dataMetric = {'Max','Avg'};
lineColors = {'k','b'};
figLegend = {'Metric Trace', 'Recording pause > 7d','Presentation Pause > 7d'};
stimPSTHSortMat = cell(size(stimPresMat,1), size(stimPresMat,2), length(epochNames));

for stim_i = 1:length(stimuliNames)
  stimData = stimPSTH(stim_i,:,:);
  for group_i = 1:length(groupTypes)
    psthData = stimData{:,group_i,strcmp(dataTypes, 'PSTH')};
    presCountData = stimData{:,group_i,strcmp(dataTypes, 'presCount')};
    recData = stimData{:,group_i,strcmp(dataTypes, 'daysSinceLastRec')};
    daysPresData = stimData{:,group_i,strcmp(dataTypes, 'daysSinceLastPres')};
    
    % vertical lines denoting long time since last Rec
    recLine = find(recData > 30);
    presLine = find(daysPresData(2:end) > 30);
    if ~isempty(recLine) && ~isempty(presLine)
      recLine = recLine(logical([1;diff(recLine)>1]));
      tmp1 = ones(length(recLine),1);
      tmp2 = ones(length(presLine),1) * 2;
      lineMat = [[recLine;presLine],[tmp1;tmp2]];
      legendInd = [1, length(tmp1)+1, length(lineMat)+1];
    else
      lineMat = [];
      legendInd = [];
    end
    
    
    metaPlotTitle = sprintf('%s - PSTH Values - %s', stimuliNames{stim_i},  groupTypes{group_i});
    h = figure('Name', metaPlotTitle, 'NumberTitle', 'off', 'units','normalized','outerposition',[0 0 1 1]);
    sgtitle(metaPlotTitle);
      
    for epoch_i = 1:length(epochs)
      % Prepare data types of Interest
      epoch = epochs{epoch_i};
      psthMax = max(psthData(:,epoch(1):epoch(2)),[],2);
      psthMean = mean(psthData(:,epoch(1):epoch(2)),2);
      dataMat = [psthMax, psthMean];
      
      % Save sorted matricies
      [~, maxSort] = sort(psthMax);
      [~, meanSort] = sort(psthMean);
      stimPSTHSortMat{stim_i, group_i, epoch_i} = [meanSort, maxSort];

      for data_i = 1:length(dataMetric)
        subPlotTitle = sprintf('%s - %s', dataMetric{data_i}, epochNames{epoch_i});
        plotInd = epoch_i + ((data_i-1) * 3);
        subplot(length(dataMetric), length(epochs), plotInd)
        
        lineArray = gobjects(size(lineMat,1)+1,1);
        lineArray(1) = plot(1:length(presCountData), dataMat(:,data_i));
        title(subPlotTitle);
        xlim([1, length(presCountData)])
        xlabel('Presentation Count')
        ylabel('Rates');
        tickLabels = xticklabels();
        newLabel = cell(length(tickLabels),1);
        for tick_i = 1:length(tickLabels)
          tickVal = round(str2num(tickLabels{tick_i}));
          newLabel{tick_i} = presCountData(tickVal);
        end
        xticklabels(newLabel);
        hold on
        if ~isempty(recLine) && ~isempty(presLine)
          for line_i = 1:size(lineMat,1)
            lineArray(line_i+1) = plot([lineMat(line_i,1), lineMat(line_i,1)], ylim(), 'Color', lineColors{lineMat(line_i,2)}, 'lineWidth',3);
          end
        end
        legend(lineArray(legendInd), figLegend,'AutoUpdate','off')
      end
    end
    savefig(h, fullfile(params.outputDir, metaPlotTitle));
    close(h);
  end
  
end

% Figure 1 - iterate through stimuli, grabbing mean and max values across
% presentations in order, plot them on a single line. Mark dates where long
% recording dates were taken with vertical lines.


end