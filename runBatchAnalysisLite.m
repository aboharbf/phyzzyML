function [analysisOutFilename] = runBatchAnalysisLite(spikePathBank, batchAnalysisParams)
%% Overwrite switches with what is currently in file, keeping the
%spikePathLoadParams, which holds most important stuff.
spikePathLoadParamsKeep = batchAnalysisParams.spikePathLoadParams;
batchAnalysisParams = load(fullfile(batchAnalysisParams.outputDir, 'batchAnalysisParams.mat'));
batchAnalysisParams.spikePathLoadParams = spikePathLoadParamsKeep;

% Load basic inputs
runList = spikePathBank.Properties.RowNames;
plotSwitch = batchAnalysisParams.plotSwitch;
figStruct = batchAnalysisParams.figStruct;
meanPSTHParams = batchAnalysisParams.meanPSTHParams;

%% Pre-Analysis processing

if ~strcmp('stimPresCount',spikePathBank.Properties.VariableNames)
  spikePathBank = stimulusStatistics(spikePathBank, batchAnalysisParams.stimStructParams);
  spikePathFile = batchAnalysisParams.spikePathLoadParams.batchAnalysisOutput;
  save(spikePathFile, 'spikePathBank', '-append')
end

% if ~exist('unitCounts','var') || ~exist('trueCellStruct', 'var') || ~isfield(spikeDataBank.(runList{end}), 'gridHoles')
%   [spikeDataBank, trueCellStruct, unitCounts, resultTable, nullCells] = tableRefFunx(spikeDataBank, cellCountParams.batchRunxls, cellCountParams.recordingLogxls);
%   saveEnv(1)
% end

% meanPSTHParams.tTestTable = resultTable;

% Report
% reportSubEventCounts(batchAnalysisParams.cellCountParams.subEventBatchStructPath, trueCellStruct)

% Remove repeated Runs
% if ~calcSwitch.excludeRepeats && isfield(analysisLog, 'repeatsExcluded')
%   error('Repeats already excluded in this spikeDataBank, delete and restart or change parameters')
% elseif calcSwitch.excludeRepeats && ~isfield(analysisLog, 'repeatsExcluded')
%   % Exclude repeated recordings at the same site.
%   for run_ind = 1:length(runList)
%     sessionName = extractBetween(runList{run_ind}, 2, length(runList{run_ind}));
%     validInd = trueCellInd(strcmp(sessionName, trueCellInfo(:,1)));
%     if sum(validInd) == 0
%       % Remove entire field if all channels are repeated recordings.
%       spikeDataBank = rmfield(spikeDataBank,(runList{run_ind}));
%     else
%       for event_ind = 1:length(spikeDataBank.(runList{run_ind}).spikesByEvent)
%         % Remove individual channel info where one of the channels is
%         % recording new units.
%         spikeDataBank.(runList{run_ind}).spikesByEvent{event_ind} = spikeDataBank.(runList{run_ind}).spikesByEvent{event_ind}(validInd);
%       end
%       spikeDataBank.(runList{run_ind}).gridHoles(validInd) = spikeDataBank.(runList{run_ind}).gridHoles(validInd);
%       spikeDataBank.(runList{run_ind}).recDepth(validInd) = spikeDataBank.(runList{run_ind}).recDepth(validInd);
%     end
%   end
%   %Save modified struct.
%   runListIndex = unitCounts.Exclude;
%   analysisLog.repeatsExcluded = 1;
%   saveEnv()
% else
%   runListIndex = unitCounts.nonExclude;
% end

%% Analyses
% Generate a cell array containing the PSTHes from spikeDataBank, along
% with additional dimension for identifying information. Expansions in
% analyses should begin here, if pulling from spikeDataBank.
if ~any(strcmp(batchAnalysisParams.spikePathLoadParams.files, 'batchAnalyzedData.mat'))
  [spikePathBank, batchAnalysisParams] = pullPSTH(spikePathBank, batchAnalysisParams);
  spikePathFile = batchAnalysisParams.spikePathLoadParams.batchAnalysisOutput;
  save(spikePathFile, 'spikePathBank', 'batchAnalysisParams', '-append')
end

% Combine PSTH across all runs for a particular stimulus.
if plotSwitch.meanPSTH
  meanPSTH(spikePathBank, batchAnalysisParams, figStruct);
%   saveEnv(0)
end

% Combine PSTH across all runs for a particular event.

if plotSwitch.subEventPSTH %&& ~exist('meanPSTHStruct','var')
  subEventPSTHStruct = subEventPSTH(spikePathBank, batchAnalysisParams, figStruct);
end

if plotSwitch.spikeEyeOverlay
  spikeEyeOverlay(spikePathBank, batchAnalysisParams, figStruct);
end

% Gather information on frame rates
if plotSwitch.frameFiringRates %&& ~exist('frameFiringStruct','var')
  [spikeDataBank, frameFiringStruct] = frameFiringRates(spikeDataBank, frameFiringParams, figStruct);
  saveEnv(1)
end

% Check whether the novelty of the runs
if plotSwitch.novelty
  assert(logical(exist('meanPSTHStruct','var')), 'Must run w/ meanPSTH enabled for novelty analysis');
  spikeDataBank = noveltyAnalysis(spikeDataBank, stimPSTH, meanPSTHStruct, [], noveltyParams, figStruct);
end

% Perform sliding window ANOVA and Omega calculations
if plotSwitch.slidingWindowANOVA % && ~isfield(spikeDataBank, [Some new field generated by function])
  spikeDataBank = slidingWindowTest(spikeDataBank, slidingTestParams, figStruct);
  saveEnv()
end

if plotSwitch.neuralDecodingTB
  batchAnalysisParams.NDTParams.spikePathLoadParams = batchAnalysisParams.spikePathLoadParams;
  NeuralDecodingTBLite(spikePathBank, batchAnalysisParams.NDTParams);
end

end